<!DOCTYPE html>
<html>

<head>
  <!-- CONFIG & TITLE -->
  <meta charset="utf-8" />
  <title>
    ReShare
  </title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
  <script src="localBiblio.js"></script>
  <script class="remove">
    // All config options at https://respec.org/docs/
    var respecConfig = {
      specStatus: "Member-SUBM",
      latestVersion: null,
      shortName: "reshare",
      subtitle: "Scalable Reliability for Data Sharing on the Web",
      submissionCommentNumber: "??", // necessary according to https://respec.org/docs/#w3c, but to be set by W3C staff
      authors: [
        {
          name: "Simon Mangel",
          company: "Computer Science 5, RWTH Aachen University",
          companyURL: "http://dbis.rwth-aachen.de/",
        },
        {
          name: "Lars Gleim",
          company: "Computer Science 5, RWTH Aachen University",
          companyURL: "http://dbis.rwth-aachen.de/",
        },
        {
          name: "Jan Pennekamp",
          company: "Communication and Distributed Systems, RWTH Aachen University",
          companyURL: "https://www.comsys.rwth-aachen.de/",
        },
      ],
      editors: [
        {
          name: "Stefan Decker",
          company: "Fraunhofer Institute for Applied Information Technology",
          companyURL: "https://www.fit.fraunhofer.de/",
          // add w3cid
        },
      ],
      //isPreview: true,
      // should be replaced by w3id URI.
      // This is also an indicator that the document to which this points should be an editor's draft!
      // Alternatively: Do not link any draft, this is rarely done in existing member submissions!
      edDraftURI: "https://w3id.org/reshare/spec/authors-draft/",

      localBiblio: localBiblio,

      xref: ["reshare", "dtc"],
    };
  </script>

  <link rel="stylesheet" href="custom_styles.css" />

  <!-- Widoco CSS -->
  <link rel="stylesheet" href="resources/primer.css" media="screen" />
  <link rel="stylesheet" href="resources/rec.css" media="screen" />
  <link rel="stylesheet" href="resources/extra.css" media="screen" />
  <link rel="stylesheet" href="resources/owl.css" media="screen" />
  <title>ReShare Ontology v0.3</title>


  <!-- WIDOCO content loading -->
  <script src="resources/jquery.js"></script>
  <script src="resources/marked.min.js"></script>
  <script class="remove">
    function loadHash() {
      jQuery(".markdown").each(function (el) { jQuery(this).after(marked(jQuery(this).text())).remove() });
      var hash = location.hash;
      if ($(hash).offset() != null) {
        $('html, body').animate({ scrollTop: $(hash).offset().top }, 0);
      }
      //loadTOC();
    }
    function loadTOC() {
      //process toc dynamically
      var t = '<h2>Table of contents</h2><ul>'; i = 1; j = 0;
      jQuery(".list").each(function () {
        if (jQuery(this).is('h2')) {
          if (j > 0) {
            t += '</ul>';
            j = 0;
          }
          t += '<li>' + i + '. <a href=#' + jQuery(this).attr('id') + '>' + jQuery(this).ignore("span").text() + '</a></li>';
          i++;
        }
        if (jQuery(this).is('h3')) {
          if (j == 0) {
            t += '<ul>';
          }
          j++;
          t += '<li>' + (i - 1) + '.' + j + '. ' + '<a href=#' + jQuery(this).attr('id') + '>' + jQuery(this).ignore("span").text() + '</a></li>';
        }
      });
      t += '</ul>';
      $("#toc").html(t);
    }
    $.fn.ignore = function (sel) {
      return this.clone().find(sel || ">*").remove().end();
    }; $(function () {
      $("#overview").load("sections/overview-en.html", null, function () {
        //Remove heading
        //$('#overview').addClass("widoco")
        $('#overv').remove();
        //Remove backlinks
        $('.backlink').remove();
      });
      $("#classes").load("sections/crossref-en.html #classes > *", null, function () {
        loadHash();
        //Remove heading
        $('#classes-headline').remove();
        //Remove backlinks
        $('.backlink').remove();
      });
      $("#objectproperties").load("sections/crossref-en.html #objectproperties > *", null, function () {
        loadHash();
        //Remove heading
        $('#properties').remove();
        //Remove backlinks
        $('.backlink').remove();
      });
      $("#dataproperties").load("sections/crossref-en.html #dataproperties > *", null, function () {
        loadHash();
        //Remove heading
        $('#dataproperties-headline').remove();
        //Remove backlinks
        $('.backlink').remove();
      });
    });
  </script>

  <!-- JS & CSS for toggling Editor's Notes and issues 
  Can simply be removed or commented out to disable -->
  <!--<script>
    var ednotes = true;
    $(function () {
      $('#respec-ui').append("<span><input type=\"image\" id=\"toggleEdnote\" src=\"https://img.shields.io/badge/Editor's_Notes-On-green.svg\" /></span>");
      $('#toggleEdnote').click(function () {
        ednotes = !ednotes;
        $('#toggleEdnote').attr("src", "https://img.shields.io/badge/Editor's_Notes-" + (ednotes ? "On-green" : "Off-red") + ".svg");
        if (ednotes) {
          $('.ednote-title').parent().removeClass("invisible");
        } else {
          $('.ednote-title').parent().addClass("invisible");
        }
      });
    });
    var issues = true;
    $(function () {
      $('#respec-ui').append("<span><input type=\"image\" id=\"toggleIssues\" src=\"https://img.shields.io/badge/Issues-On-green.svg\" /></span>");
      $('#toggleIssues').click(function () {
        issues = !issues;
        $('#toggleIssues').attr("src", "https://img.shields.io/badge/Issues-" + (issues ? "On-green" : "Off-red") + ".svg");
        if (issues) {
          $('.issue').removeClass("invisible");
        } else {
          $('.issue').addClass("invisible");
        }
      });
    });
  </script>
  <style>
    .invisible {
      display: none;
    }

    #toggleEdnote,
    #toggleIssues {
      border: none;
      opacity: .75;
      margin-right: 1em;
      min-width: 3.5em;
      height: 2.5em;
    }
  </style>-->
</head>

<body>

  <p class="copyright">
    Copyright Â© 2022 Fraunhofer Institute for Applied Information Technology. This document is available under the <a href="http://www.w3.org/Consortium/Legal/copyright-documents">W3C Document License</a>. See the <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">W3C Intellectual Rights Notice and Legal Disclaimers</a> for additional information.
  </p>

  <!-- ABSTRACT -->
  <section id="abstract">
    The ReShare system constitutes a uniform approach to ensure accountable and trustworthy data sharing and collaboration in Open Data ecosystems based on Digital Transmission Contracts (DTCs).
    DTCs are bilaterally signed digital records immutably certifying the data and context of a data transmission without the typical overhead of distributed ledger technologies.
    By leveraging open Web technologies, a simple and common cryptography architecture, and a bilateral signature paradigm, the system promises superior performance and scalability to common approaches such as manual records management or blockchain-based solutions while providing immutability and fraud protection guarantees sufficient for a variety of use cases, such as data accountability and liability assurance in aircraft manufacturing.
    In this document, we specify (1) the structure and representations of DTCs, (2) the <i>ReShare ontology</i> used to embed DTCs into the Semantic Web, and (3) the protocol and necessary mechanisms to create and verify DTCs.
  </section>
  <!-- DOCUMENT STATUS -->
  <!-- (can probably be ignored) -->
  <section id="sotd"></section>
  <!-- MAIN CONTENT STARTS HERE -->
  <section id="introduction" class="informative">
    <h2>Introduction</h2>

    <div class="tlcontent">
      <p>
        Information sharing between parties on the Internet is omnipresent.
        However, there is a severe lack of efficient and scalable methods to prove the existence, contents, and context of a data transfer.
      </p>

      <p>
        Especially in the context of data-driven business models, data <a>trustworthiness</a> and <a>reliability</a> are extremely important to minimize data quality-related risks in the business model.
        Therefore, an approach, which is able to guarantee both of these properties in the context of <a>data sharing</a>, and scale up to the future needs w.r.t. data throughput, is needed.
        The relevance of inter-organizational data sharing is stressed by the vision of an <i>Internet of Production</i>
        (IoP), where open data sharing approaches leverage cross-domain collaboration, resulting in a multitude of benefits for all participants [[?TowardsIoP]].
      </p>

      <p>
        In this document, we describe <em><b>ReShare</b> (Reliable Data Sharing through Digital Transmission Contracts)</em>.
        <em>ReShare</em> provides data integrity, authenticity, and immutability in data exchanges between two parties through digital contracting using on-demand bilateral signatures.
        By establishing an irrefutable commitment by the two parties to the data transmission, data trustworthiness, and reliability emerge.
      </p>
      <p>
        <em>ReShare</em> is a unified solution for the Web, built from open Web technology, and adresses an important research gap.
        That is, ReShare is both highly scalable, and does not rely on pre-existing trust relations, which both are essential requirements in the context of the Web.
      </p>
      <!-- Delimitation/relation to other current work -->
      <p>
        <em>ReShare</em> employs signature-based strong data immutability to be feasible as a unified solution for the Web.
        Further, the design provides a system which is flexible to the payload (i.e., the shared data to be made trustworthy and reliable), and therefore supports any Web resource or content, including plain text, Linked Data payloads, JSON, and binary data, amongst other formats.
      </p>
      <p>
        The structure of this document is as follows:
        In Section <a href="#primer"></a>, we introduce the relevant terminology and outline typical data sharing scenarios motivating the need for scalable immutability, authenticity, and integrity.
        In Section <a href="#digital-transmission-contracts"></a>, we describe the paradigm and structure of Digital Transmission Contracts (DTCs), which are at the core of <em>ReShare</em>.
        After that, we propose the <em>ReShare ontology</em> in Section <a href="#reshare-ontology"></a>, which is used to define the semantics of DTCs in the context of Linked Data.
        Finally, we describe the generation and verification mechanisms needed to process DTCs in Section <a href="#dtc-generation-and-verification"></a>.
      </p>
    </div>

  </section>
  <section id="conformance">
  </section>
  <section id="primer" class="informative">
    <h2>A Primer to Data Sharing</h2>
    <div class="tlcontent">
      <p>
        For a formal understanding of data sharing and its applications, Section <a href="#primer-background"></a> gives an introduction to data sharing, and Section <a href="#primer-terminology"></a> formalizes the used terminology.
        In Section <a href="#primer-example-scenario"></a>, we introduce a use case scenario which we use throughout the remainder of the document for clarifications and examples.
      </p>
    </div>

    <section id="primer-background">
      <h3>Background</h3>
      <div class="tlcontent">
        <p>
          <!-- Introduce the challenge -->
          <a>Data sharing</a> is a central concept of the Web.
          In recent years, fueled by developments in data-driven business and industries, challenges of fitting the process of <a>data sharing</a> to more advanced requirements, such as <a>trustworthiness</a> and <a>reliability</a>, have emerged.
        </p>

        <p>
          As the source of data used in industrial collaborations often is external, it has no inherent trustworthiness compared to self-produced data.
          This increases the risk of legal and safety issues for the data user, as the liability for incidents caused by the data cannot immediately be attributed to its source.
        </p>

        <p>
          <!-- State benefits of solving -->
          Solving the challenges of data <a>trustworthiness</a> and <a>reliability</a> has been shown to enable a variety of novel business models based on data-driven decision making [[?OEZER-TRUST]], where the data sharing process is made transparent to the data users through the ability to reliably trace the provenance of data.
          Further, data sharing in inter-organizational collaborations has been shown to provide the basis for benefits such as cost reductions, increased profit margins, and general improvements in product quality and safety [[?TowardsIoP]].
        </p>
        <section class="notoc">
          <h3>The Challenge of Data Trustworthiness</h3>
          <p>
            Wherever corrupted or forged data imposes a relevant risk, the user should carefully assess the trustworthiness of its data.
            That is, users need some rationale for trusting the authenticity and correctness of data.
            This rationale may be a strong trust relationship with the data source, some form of digital proof of authenticity and integrity, or even the result of manual data curation.
          </p>
        </section>
        <section class="notoc">
          <h3>The Challenge of Data Reliability</h3>
          <p>
            Especially in safety-critical environments, the data user might need confidence in the reliability of data,
            i.e., that the data itself is valuable and usable beyond its initial use, i.e., it should keep its initial value to the user.
            One relevant aspect of data reliability is that the data source cannot easily repudiate the state of the shared data later, neither by forging contradicting data, nor by repudiating the earlier data transmission at all.
          </p>
          <p>
            Similar as for data trustworthiness, some kind of rationale for this reliability is necessary, e.g., a strong pre-existing trust relationship with the data source, or some kind of mechanism to notice adversaries by the data source and solve the resulting conflicts.
          </p>
        </section>
        <section class="notoc">
          <h3>Relevance of the Web</h3>
          <p>
            <!-- We use open Web tech! This is good! -->
            The Web is a prime candidate to enable reliable data sharing as it is commonly used to exchange information between different stakeholders.
            As the importance of Open Data increases steadily, a system for trustworthy and reliable data sharing built using open Web standards and technology can both profit from the inherent data sharing capabilities of the Web, and facilitate integration into an Open Data paradigm.
          </p>

          <p>
            <!-- Related work doesn't cut it, Web-scale is more challenging -->
            Existing approaches to trustworthy and reliable data sharing, such as mutually trusted mediators and distributed ledgers, might be applicable to small-scale use cases with either pre-existing trust relations or low requirements to system scalability.
            However, Web-scaled systems have specific, more challenging needs.
            First, the possible limitation of a trust assumption in a system would severely limit its potential, as common trust in a central mediator can hardly be assumed in a global network such as the Web.
            Second, existing no-trust solutions, such as manual data curation and even distributed ledger technology, do not meet tomorrow's needs toward scalability for efficient usage on the whole Web.
          </p>
        </section>
      </div>

    </section>

    <section id="primer-terminology" class="informative">
      <h3>Terminology</h3>

      <p>In the following, we introduce the necessary terminology used throughout the document.</p>

      <section id="primer-terminology-concepts" class="informative">
        <h3>Concepts</h3>
        <p>
          While the presented terms and concepts may have different definitions in practice, <em>ReShare</em> builds on the terminology introduced in the following.
        </p>
        <dl>
          <dt><dfn>data sharing</dfn></dt>
          <dd>
            Data sharing denotes a process in which one party, the <a>sender</a>, grants a second party (or group of parties), the <a>receiver</a> (or <a>receivers</a>), access to a set of data.
            The data is then transmitted from the <a>sender</a> to the <a>receiver</a> as a <em>data transmission</em>.
          </dd>
          <dt><dfn>trustworthiness</dfn></dt>
          <dd>
            (Data) trustworthiness denotes the subjective judgment of the data correctness by the data user.
            The term <em>correctness</em> here includes integrity and authenticity, but is not limited to it.
            Rather, it covers the complete data pipeline, and thus, for example, also considers errors in measurement,
            inaccuracies, or intentional forgery or manipulation by the (authentic) data source.
          </dd>
          <dt><dfn>reliability</dfn></dt>
          <dd>
            Data reliability denotes the guarantees available to a data user to prove aspects of data correctness before, at, and after the initial use of the data.
          </dd>
          <dt><dfn>immutability</dfn></dt>
          <dd>
            <p>
              We define data to be immutable if it can be uniquely referenced, and that reference always refers to exactly the same data at any point in time.
              This directly implicates that once published, data cannot be manipulated afterward without assigning a different identifier.
            </p>
            <p>
              We further differentiate between <em>weak</em> and <em>strong</em> data immutability:
            <ul>
              <li>In a <em>weak</em> data immutability system, an identifier scheme defines how data can be created and published in an immutable manner.
                However, such a system does not protect against misuse of the immutability scheme, and has no in-built mechanisms to immediately notice or resolve misuses.
              </li>
              <li>
                In a <em>strong</em> immutability system, any action violating the immutability property leads to an inconsistent state of the system.
                The system provides mechanisms to both recognize such inconsistencies, and resolve them to a consistent state.
                Therefore, at any point in time, one can unambiguously determine the correct state of any immutable data point.
                <p class="note">
                  It is unclear whether a perfect strong immutability system can practically exist.
                  Most systems striving at providing strong data immutability come with practical assumptions and limitations.
                  For example, the consensus state of a distributed consensus mechanism can be determined with a high probability, but not with full certainty.
                  Furthermore, if a large proportion of the participants of a consensus network collude, the immutability guarantee cannot hold.
                </p>
              </li>
            </ul>
          </dd>
        </dl>
      </section>
      <section id="primer-terminology-process" class="informative">
        <h3>Process and Agents of Data Sharing</h3>

        <dl>
          <dt><dfn>IRI</dfn></dt>
          <dd>
            An <em>Internationalized Resource Identifier</em> (IRI) [[RFC3987]] is a globally unique identifier in the form of a sequence of characters from the Universal Character Set, as defined in [[[RFC3987]]].
          </dd>
          <dt><dfn>sender</dfn></dt>
          <dd>
            Denotes the sending party in a data transmission.
            This term is always used in the context of a data transmission and refers to the direction of dataflow.
            Each sender has an associated globally unique identifier in the form of an <a>IRI</a>.
            Means by which this <a>IRI</a> can unambiguously identify a party are further discussed in Section <a href="#considerations-iricertlink"></a>.
          </dd>
          <dt><dfn>receiver</dfn></dt>
          <dd>
            Denotes the receiving party in a data transmission.
            This term is always used in the context of a data transmission and refers to the direction of dataflow.
            Each sender has an associated globally unique identifier in the form of an <a>IRI</a>.
            Means by which this <a>IRI</a> can unambiguously identify a party are further discussed in Section <a href="#considerations-iricertlink"></a>.
          </dd>
          <dt><dfn>resource</dfn></dt>
          <dd>
            A data point or object which can be uniquely identified through an <a>IRI</a>.
          </dd>
          <dt><dfn>fact</dfn></dt>
          <dd>
            <p>
              An immutable revision of a <a>resource</a>, uniquely and persistently referenced through an <a>IRI</a>
              specific to the revision.
              This implies that given the <a>IRI</a>, the data identified by the <a>IRI</a> cannot be altered.
              In this context, the persistent <a>IRI</a> of a fact can also be referred to as a <dfn>FactID</dfn>.
            </p>
            <p class="note">
              The term originated from <em>FactDAG</em>, a formalization model of data interoperability which was proposed in a research paper by Gleim et al. [[?FactDAG]], where it denotes a data point that was explicitly made immutable by means of a revisioning system.
            </p>
          </dd>
        </dl>
      </section>
    </section>
    <section id="primer-example-scenario" class="informative">
      <h3>Example Scenario</h3>

      <div class="tlcontent">
        <p>
          We employ an example scenario of inter-organizational data sharing in aircraft manufacturing to clarify the concepts and terminology introduced above.
        </p>
        <section class="notoc">
          <h3>Setup</h3>
          <p>
            This example considers the supplier-manufacturer relation in the highly-regulated and safety-critical process of aircraft engineering.
          </p>

          <p>
            Three parties are involved in the scenario: Two part suppliers, <i>A-Corp</i> and <i>B-Tech</i>, as well as a manufacturer <i>C-Aviation</i>, which assembles the final product (here: aircraft).
          </p>

          <p>
            In this simple scenario, both A-Corp and B-Tech supply parts (wings and propellers) to C-Aviation.
            Additionally, besides a flow of physical products, a dataflow exists in parallel.
            The data might include relevant production data, conformance certificates, etc.
          </p>

          <p>In this dataflow, A-Corp and B-Tech are the <a>senders</a>, and C-Aviation is the <a>receiver</a>.</p>

          <p>
            Further, the precision of the placement of a certain rivet used in a wing by A-Corp might be a <a>resource</a> as part of the production data shared with C-Aviation.
            By using a revision identifier, e.g., the timestamp of measurement, the <a>resource</a> can be lifted to an immutable resource revision, i.e., a <a>fact</a>.
          </p>

          <p>
            The scenario, including the flow of physical goods and data, is visualized below.
          </p>

          <figure id="fig-example-scenario-1" style="text-align: center;">
            <object data="figures/example-scenario-1.svg" style="width:100%;" type="image/svg+xml" aria-describedby="fig-example-scenario-1"></object>
            <p id="fig-example-scenario-1-alt">
              Example scenario in aircraft manufacturing.
            </p>
            <figcaption>
              The example scenario in aircraft manufacturing.
              Besides a physical dataflow of the suppliers (A and B) to the manufacturer (C), production data is shared with C.
            </figcaption>
          </figure>
        </section>

        <section class="notoc">
          <h3>Trustworthiness & Reliability through Common Methods</h3>

          <p>
            Data shared between the parties is used in processes such as production and audits, which are critical for product safety.
            Thus, it is extremely important that C-Aviation assesses the trustworthiness and reliability of the data.
            These properties can reduce the risk of data-caused damage or shift liability for said damage to the suppliers.
          </p>

          <p>
            To establish a common ground of trustworthiness and reliability, C-Aviation agrees upon a conformance agreement in the form of a paper-based contract with its suppliers.
            This practice naturally is a labor-intensive process, as such documents have to be created, sent between the companies, and archived physically.
            Here, the data storage layer comprises physical archives, where the paper-based contracts are stored.
          </p>
        </section>

        <p>After describing the concept of DTCs in the following, we will discuss an application to this scenario together with corresponding benefits in Section <a href="#dtc-example-application"></a></p>
      </div>
    </section>
  </section>
  <section id="digital-transmission-contracts">
    <h2>Digital Transmission Contracts (DTCs)</h2>

    <section id="dtc-signature-paradigm" class="informative">
      <h3>Mutual Commitment through Bilateral Signatures</h3>
      <div class="tlcontent">
        <p>
          DTCs leverage digital signatures to create <a data-lt="immutability">strong data immutability</a> within a defined scope, which we further describe below.
          DTCs deviate from the common paradigm of document signatures by enforcing the signatures to be created during data transmission, thus allowing to involve a second party, the <a>receiver</a>, in the signature process.
        </p>
        <p>
          For a clear differentiation, we can classify common uses of signatures into one of the following two paradigms:
        </p>
        <dl>
          <dt><dfn class="lint-ignore">pre-created signatures</dfn></dt>
          <dd>
            Also known as <dfn class="lint-ignore">document signatures</dfn>, are signatures that are created by the data source (or publisher) and are not bound to a specific transmission.
            Thus, such signatures can be efficiently created on publication and only need to be created once in the lifetime of the document.
            This type of signatures is usually used on data platforms, document stores, etc.
          </dd>
          <dt><dfn class="lint-ignore">on-demand signatures</dfn></dt>
          <dd>
            Also known as <dfn class="lint-ignore">message signatures</dfn>, are signatures that are specific to a single data transmission or communication process.
            Therefore, On-demand signatures cannot be pre-computed in most cases, as they are bound to that specific transmission or communication process.
            On-demand signatures are commonly used to establish authenticity and non-repudiation in messaging and communication protocols, e.g., <a href="https://datatracker.ietf.org/doc/html/rfc4880">OpenPGP</a>
            [[RFC4880]].
          </dd>
        </dl>
        <p class="note">
          The terms of pre-created and on-demand signatures are not canonical, as a clear differentiation between these signature paradigms can rarely be found in literature.
        </p>

        <p>
          DTCs are linked to a specific data transmission and comprise a signature by both the <a>sender</a> and the <a>receiver</a>.
          Therefore, the signatures cannot be pre-computed during publishing, i.e., they are <a>on-demand signatures</a>.
        </p>

        <p>
          Because the <a>receiver</a> signs the state of the data, the <a>sender</a> alone cannot forge a valid DTC by itself.
          Therefore, as long as <a>sender</a> and <a>receiver</a> do not collude to forge rogue signature pairs, the valid DTC can unambiguously be determined by the pair of valid signatures by both parties.
          Thus, this approach provides <a data-lt="immutability">strong data immutability</a> under the assumption of no inter-party collusion.
        </p>

        <p>
          While the assumption of no inter-party collusion may seem limiting at first, it still covers a substantial set of use cases, i.e., inter-party conflicts of <a>sender</a> and <a>receiver</a>.
          Thus, DTCs can be applied wherever <a>sender</a> and <a>receiver</a> do not trust each other and want to have mutual proof of the data sharing process.
          In our example from Section <a href="#primer-example-scenario"></a>, this assumption covers a variety of possible scenarios, including proving data authenticity in liability conflicts and creating secure and non-repudiable product conformance and quality certificates between C-Aviation and the two suppliers.
        </p>

        <p>
          If the <a>receiver</a> would not sign the DTC, the <a>sender</a> could create signatures for arbitrary data.
          If a rogue <a>sender</a> would now sign different versions of the same <a>fact</a>, the correct version of the <a>fact</a> would become ambiguous, thus violating the <a data-lt="immutability">data immutability</a>.
        </p>
        <p>
          In the example from Section <a href="#primer-example-scenario"></a>, the production data of a propeller supplied by B-Tech may hint at a production fault that leads to an incident with the respective airplane.
          During the incident inspection and liability process, B-Tech might now supply corrected data together with valid certificates and thereby claim that the supplied parts were not faulty to the best of their knowledge.
          The data immutability is violated in this case, as one cannot unambiguously determine the original version of B-Tech's production data.
        </p>
      </div>
    </section>
    <section id="dtc-example-application" class="informative">
      <h2>Application to the Example Scenario</h2>

      <div class="tlcontent">
        <p>
          In Section <a href="#primer-example-scenario"></a>, we introduced an exemplary scenario from the aviation industry.
          The original process relied on costly and management-intensive paper-based contracting and archiving methods.
        </p>
        <p>
          If the concept of DTCs is applied to the exemplary data sharing process, substantial parts of the system can be implemented digitally.
          These parts comprise of
        <ul>
          <li>the contracts, in which an agreement about the data transmission is made, including the signatures by both parties, and</li>
          <li>the storage system for storing and archiving the transmission contracts.</li>
        </ul>
        <p>
          The application of DTCs within the data sharing process is visualized below.
        </p>
        <figure id="fig-example-scenario-2" style="text-align: center;">
          <object data="figures/example-scenario-2.svg" style="width:100%;" type="image/svg+xml" aria-describedby="fig-example-scenario-2"></object>
          <p id="fig-example-scenario-2-alt">
            Application of DTCs to the example scenario in aviation.
          </p>
          <figcaption>
            The application of DTCs to the example scenario in the aviation industry.
            DTCs (1) are certified by sender and receiver, (2) secure the transmitted data, and (3) are stored (longtime) in digital secure storage systems.
          </figcaption>
        </figure>
        <p>
          In the example scenario, a DTC is linked to all three layers of the data sharing process:
        <ol>
          <li>
            <b>Physical layer:</b> <br />
            The parties A-Corp and C-Aviation both certify (1) the DTC by adding a digital signature.
            Both parties are linked to their physical identities by a public key certificate (see Section <a href="#dtc-data-structure"></a> for details).
            Further, the production data produced by factories is secured in the DTC (2).
          </li>
          <li>
            <b>Data Storage layer:</b> <br />
            Both parties can store the DTC to profit from its benefits in later situations, including audits and liability conflicts.
            In the example of aircraft manufacturing, the parties are even required legally to securely store the contracts for several years.
          </li>
          <li>
            <b>Dataflow layer:</b> <br />
            The DTC itself is constructed in parallel to the underlying production data transmission in a generation handshake (see Section <a href="#dtcgenver-generation"></a> for details).
          </li>
        </ol>
      </div>
    </section>
    <section id="dtc-data-structure">
      <h3>DTC Data Structure</h3>
      <div class="tlcontent">
        <p>
          DTCs have a defined object structure.
          Its components are defined as <dfn>contract fields</dfn>.
        </p>

        <p>
          In the following, we define the content and substructure of the <a>contract fields</a>.
          All fields not explicitly marked as optional MUST be present in any valid DTC.
          A valid DTC MUST NOT contain any fields which are not specified below.
        </p>

        <p class="note">
          To disambiguate between the terms defined in Section <a href="#primer-terminology"></a> and the contract fields above, contract fields are always typeset as red-orange monospace font, e.g., <a>sender</a>
          vs <a data-lt="dtc-sender">sender</a>).
        </p>
        <dl>
          <dt><dfn data-lt="dtc-baseIRI" data-lt-noDefault><code>baseIRI</code></dfn></dt>
          <dd>
            <p>
              The base <a>IRI</a> which can be used to uniquely identify the DTC.
            </p>
            <p>
              The base <a>IRI</a> is selected by the <a>sender</a> or <a>receiver</a> during the DTC generation handshake (see Section <a href="#dtcgenver-generation"></a>) and is used as both the <a>IRI</a> for the DTC itself, as well as an <a>IRI</a> prefix for its subcomponents in the JSON-LD representation (see Section <a href="#dtc-representations-jsonld"></a>)
            </p>
            <p>
              The base <a>IRI</a> SHOULD end with a <code>#</code> delimiter, i.e., the <code>"#" ifragment</code> part,
              where <code>ifragment</code> is empty, such that the sub-IRIs assigned in the <a href="#dtc-representations-jsonld">JSON-LD representation</a> (Section <a href="#dtc-representations-jsonld"></a>) use the <code>ifragment</code> part to identify the subcomponent.
            </p>
          </dd>
          <dt><dfn data-lt="dtc-sender" data-lt-noDefault><code>sender</code></dfn></dt>
          <dd>
            <p>
              Identity of the <a>sender</a>, i.e., the <a>sender</a>'s <a>IRI</a> and a public key certificate.
              The <a>IRI</a> uniquely links the DTC to the <a>sender</a>, and the public key certificate contains the public key needed to verify the <a>sender</a>'s signature contained in <a data-lt="dtc-senderSig"><code>senderSig</code></a>.
            </p>
            <p>The <a data-lt="dtc-sender"><code>sender</code></a> field has the following subcomponents:</p>
            <dl>
              <dt><code>authID</code></dt>
              <dd>
                The <a>IRI</a> of the <a>sender</a>.
                SHOULD be related to the public key certificate contained in the <code>cert</code> field.
                A discussion on linking the certificate to the authority <a>IRI</a> can be found in Section <a href="#considerations-iricertlink"></a>.
              </dd>
              <dt><code>cert</code></dt>
              <dd>
                An X.509 public key certificate or certificate chain of the <a>sender</a>.
                The verification of the certificate (chain) requires a shared trust anchor (e.g., a commonly trusted root CA).
              </dd>
              <dt><code>type</code></dt>
              <dd><code>"X509"</code>/<code>"X509-single"</code> for a single X.509 certificate,
                <code>"PKCS7"</code>/<code>"X509-PKCS7-chain"</code> for a certificate chain bundled into a <a href="https://datatracker.ietf.org/doc/html/rfc2315">PKCS #7</a> message [[RFC2315]].
                These two types MUST be implemented.
                While we do not specify other types in this document, this field can be used to implement different certificate types in future extensions.
              </dd>
              <dt><code>encoding</code></dt>
              <dd>Encoding of the certificate.
                Always set to <code>"base64"</code>, which refers to the certificate (chain) in DER notation encoded using <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-4">Base64</a> [[RFC4648]].
                The purpose of this field is both for the data structure to be self-describing and to allow for possible extensions of other encodings.
              </dd>
            </dl>
          </dd>
          <dt><dfn data-lt="dtc-receiver" data-lt-noDefault><code>receiver</code></dfn></dt>
          <dd>
            <p>
              Identity of the <a>receiver</a>, i.e., an <a>IRI</a> and a public key certificate.
              The <a>IRI</a> uniquely links the DTC to the <a>receiver</a>, and the public key certificate contains the public key needed to verify the <a>receiver</a>'s signature contained in <a data-lt="dtc-receiverSig"><code>receiverSig</code></a>.
            </p>
            <p>The substructure is equivalent to the <a data-lt="dtc-sender"><code>sender</code></a> field.</p>
          </dd>
          <dt><dfn data-lt="dtc-senderSig" data-lt-noDefault><code>senderSig</code></dfn></dt>
          <dd>
            <p>
              The contract signature created by the <a>sender</a> according to Section <a href="#dtc-signatures-creation"></a>.
            </p>
            <p>
              The <a data-lt="dtc-senderSig"><code>senderSig</code></a> field has the following subcomponents:
            </p>
            <dl>
              <dt><code>sig</code></dt>
              <dd>The signature data, encoded as a string according to the <code>encoding</code> field (see below).</dd>
              <dt><code>type</code></dt>
              <dd>
                The signature type used.
                MUST always be set to <code>"urn:oid:1.2.840.113549.1.1.10"</code>, which is the <a href="https://datatracker.ietf.org/doc/html/rfc3061">Object Identifier (OID)</a> [[RFC3061]] of the <a href="https://datatracker.ietf.org/doc/html/rfc8017#section-8.1"><code>RSASSA-PSS</code></a>
                signature scheme as defined in <a href="https://datatracker.ietf.org/doc/html/rfc8017#section-8.1">PKCS #1 v2.2</a>
                [[RFC8017]].
                We use the <a href="https://www.rfc-editor.org/rfc/rfc3001">URN Namespace of Object Identifiers</a>
                [[RFC3001]] to make the identifier interpretable as an IRI.
                The purpose of this field is both for the data structure to be self-describing and to allow for possible extensions of other signature schemes.
              </dd>
              <dt><code>encoding</code></dt>
              <dd>
                Encoding of the signature data.
                MUST always be set to <code>"base64"</code>, specifying that the signature value is encoded using <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-4">Base64</a> [[RFC4648]] according to Section <a href="#dtc-signatures-creation"></a>.
                The purpose of this field is both for the data structure to be self-describing and to allow for possible extensions of other encodings.
              </dd>
            </dl>
          </dd>
          <dt><dfn data-lt="dtc-receiverSig" data-lt-noDefault><code>receiverSig</code></dfn></dt>
          <dd>
            Contract signature created by the <a>receiver</a>.
            Analogous to <a data-lt="dtc-senderSig">senderSig</a>.
          </dd>
          <dt><dfn data-lt="dtc-facts" data-lt-noDefault><code>facts</code></dfn></dt>
          <dd>
            <p>
              A set of one or more <em>fact checksums</em>.
            </p>
            <p>
              This field binds the DTC to the state of the transmitted data by including <a>fact</a> checksums, which are implemented using cryptographic hash functions.
            </p>
            <p>
              Any implementation SHOULD interpret this field as an unordered list.
              Whenever a canonical representation is needed, the set MUST be transformed into an ordered list by sorting the elements lexicographically by <a data-lt="dtc-factID">factID</a> in the <a href="https://datatracker.ietf.org/doc/html/rfc3629">UTF-8</a> encoding [[RFC3629]] (e.g., see Section <a href="#dtc-signatures-preprocessing"></a>).
            </p>
            <p>A single <em>fact checksum</em> has the following subcomponents:</p>
            <dl>
              <dt><dfn data-lt="dtc-facts-factID" data-lt-noDefault><code>factID</code></dfn></dt>
              <dd>
                The <a>IRI</a> of the <a>fact</a>.
                MUST be unique in the set of <a data-lt="dtc-facts">facts</a>.
              </dd>
              <dt><dfn data-lt="dtc-facts-requestedID" data-lt-noDefault><code>requestedID</code></dfn></dt>
              <dd>
                <em>(Optional)</em>
                During the DTC generation mechanism (cf. Section <a href="#dtcgenver-generation"></a>), the <a>sender</a> MAY update the <a>IRI</a> in <a data-lt="dtc-facts-factID">factID</a> (e.g., in order to provide a persistent fact IRI for long-term referenceability).
                In this case, this field contains the <a>IRI</a> which was originally requested.

                <div class="note">
                  <p>
                    The procedure of updating the <a data-lt="dtc-facts-factID">factID</a> is included to support <a data-lt="dtc-facts-factIR">factID</a> negotiation.
                    Example scenarios:
                  </p>
                  <ul>
                    <li>
                      The <a>receiver</a> does not know the revision ID, which transforms a <a>resource</a> to a <a>fact</a> by means of an immutable revisioning scheme, and thus only requests the latest revision of a <a>resource</a>.
                      The <a>sender</a> adds the latest revision ID to the <a data-lt="dtc-facts-factID">factID</a> to identify an immutable <a>fact</a>.
                    </li>
                    <li>
                      The <a>receiver</a> uses a deprecated <a>fact</a> identification scheme.
                      The <a>sender</a> can transform the deprecated <a data-lt="dtc-facts-factID">factID</a> into a new one.
                    </li>
                  </ul>
                </div>
              </dd>
              <dt><dfn data-lt="dtc-facts-alg" data-lt-noDefault><code>&lt;alg&gt;</code></dfn></dt>
              <dd>
                <p>
                  The checksum, created by hashing a serialization of the <a>fact</a>.
                </p>

                <p>
                  The hash algorithm MUST be specified through the field name, i.e., <code>&lt;alg&gt;</code> MUST be replaced by one of the supported algorithms listed below.
                </p>
                <p>
                  The hash values MUST be encoded as a hexadecimal string, i.e., using digits and the letters a-f or A-F.
                  The encoding SHOULD use lowercase letters.
                </p>
                <p>
                  The supported hash algorithms are cryptographic hash functions, so that an attacker cannot forge data that collides with the checksum.
                  Such a vulnerability could lead to misuse of existing DTCs, or ambiguity w.r.t. the verifiability of the underlying data.
                </p>
                <p>
                  Currently supported algorithms:
                <ul>
                  <li><code>sha256</code>, <code>sha384</code>, <code>sha512</code>: Variants of <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">SHA-2</a> [[[FIPS-180-4]]]</li>
                </ul>
              </dd>
              <dt><dfn data-lt="dtc-facts-serialization" data-lt-noDefault><code>serialization</code></dfn></dt>
              <dd>
                A serialization identifier.
                In this document, we specify a baseline set of serialization identifiers.
                Every implementation MUST be able to interpret these serialization identifiers.
                Extensions to these identifiers MAY be specified in the future.
                <ul>
                  <li><code>"binary"</code>: A (trivial) binary representation of the <a>fact</a></li>
                  <li><code>"string"</code>: A (trivial) string representation of the <a>fact</a></li>
                  <li><code>"canonical_json"</code>: A representation of the <a>fact</a> as canonicalized JSON according to the <a href="https://datatracker.ietf.org/doc/html/rfc8785">JSON Canonicalization Scheme (JCS)</a> [[RFC8785]].</li>
                  <li><code>"URDNA2015"</code>: The Linked Data associated with a <a>fact</a>, serialized as normalized N-Quads [[N-Quads]] according to the <a href="https://json-ld.github.io/rdf-dataset-canonicalization/spec/index.html">URDNA2015</a>
                    algorithm.
                    <p class="note">
                      We recognize that Linked Data canonicalization is an open issue, and the specification of the specified algorithm is at a draft status.
                      As the algorithm is not a direct component of <em>ReShare</em>, and we argue for an extensible serialization identifier scheme, we consider this remark to be tolerable.
                    </p>
                  </li>
                </ul>
                A <em>trivial</em> serialization of a given resource MUST be interpretable without the need to perform any transformations.
                E.g., if the fact is a JPEG image, the binary serialization (identified by the <code>"binary"</code>
                identifier) can be considered trivial, as JPEG is a binary file format and does not need to be transformed.
                A JSON document, however, cannot be trivially serialized as a binary object without transformations, as the choice of the character set, the canonicalization scheme, etc. are ambiguous.
              </dd>
            </dl>
          </dd>
          <dt><dfn data-lt="dtc-customContent"><code>senderCustomContent</code>/<code>receiverCustomContent</code></dfn>
          </dt>
          <dd>
            <p><em>(Optional)</em> DTC fields that MAY be used to add custom content or metadata to a DTC as a JSON object.</p>

            <p>If one of these fields is present, it MUST contain exactly one JSON object (i.e., enclosed by curly brackets).</p>
          </dd>
          <dt><dfn data-lt="dtc-timestamp" data-lt-noDefault><code>timestamp</code></dfn></dt>
          <dd>
            A timestamp that binds the DTC to the time of transmission. Specifically, it binds to the point in time during DTC generation, where one of the two involved parties adds the fact checksums to the DTC.
            The timestamp is encoded as a string in the <a href="https://datatracker.ietf.org/doc/html/rfc3339#section-5.6">Internet date/time format</a>
            [[RFC3339]], which is a profile of <a href="http://www.iso.org/iso/catalogue_detail?csnumber=40874">ISO 8601</a> [[ISO8601]].
          </dd>
        </dl>
      </div>

    </section>
    <section id="dtc-representations">
      <h3>DTC Representations</h3>

      <div class="tlcontent">
        <p>
          By default, DTCs are represented as JSON [[RFC8259]].
          To make DTCs interpretable as Linked Data, we further define an associated JSON-LD [[JSON-LD11]] context.
          We deem JSON the default representation, as it can be transformed to the JSON-LD representation without context by the procedure defined below, and thus reduces the overhead in storage and transmission of (partial)
          DTCs.
        </p>

        <p>
          Any implementation MUST support the creation, validation, and interpretation of the JSON DTC representation, which we describe in Section <a href="#dtc-representations-json"></a>.
        </p>
        <p>
          Implementations MAY support the transformations from and to JSON-LD.
          In this case, these transformations MUST be implemented according to Section <a href="#dtc-representations-jsonld"></a>.
        </p>
      </div>
      <section id="dtc-representations-json">
        <h3>JSON</h3>

        <p>
          We define a default JSON representation for DTCs.
          Every contract field is represented by a root-level submember of a JSON object.
          The content of each field and sub-field is described above in Section <a href="#dtc-data-structure"></a>.
        </p>

        <p>
          To specify the structure of the JSON representation of a DTC, we build upon the specification of <a href="https://json-schema.org/draft/2020-12/json-schema-core.html">JSON Schema</a>
          [[JSON-SCHEMA]][[JSON-SCHEMA-VALIDATION]].
          While we recognize that this specification is still in a draft state, we find this tolerable due to the nature of this document being a member submission.
          We further specifically use the <code>2020-12</code> version of the draft of <a href="https://json-schema.org/draft/2020-12/json-schema-core.html">JSON Schema</a> to avoid ambiguities.
        </p>

        <p>
          We define three schemas: The schema for a <a href="schemas/partial_dtc.schema.json" class="external" target="_blank">partial DTC</a>, the schema for a <a href="schemas/dtc.schema.json" class="external" target="_blank">complete DTC</a>, and the schema for a <a href="schemas/dtc_only_signatures_missing.schema.json" class="external" target="_blank">partial DTC, where only the two signatures may be missing</a>.
          The two latter schemas extend the <a href="schemas/partial_dtc.schema.json" class="external" target="_blank">partial DTC schema</a> by requiring the fields to be present.
        </p>

        <p>
          For a JSON representation of a DTC to be syntactically valid, a JSON schema validator implemented according to the <code>2020-12</code> version of JSON schema MUST successfully test the JSON representation to the JSON schema of a complete DTC.
        </p>

        <p>
          In the following, we give an example of a complete DTC as a JSON object, according to the descriptions above.
          The contract contains four <a>fact</a> checksums (in <a data-lt="dtc-facts">facts</a>), where the <a>fact</a>
          itself could trivially be serialized as a string.
          The public key certificates (in <a data-lt="dtc-sender">sender</a> and <a data-lt="dtc-sender">receiver</a>)
          are single X.509 certificates directly signed by an imaginary root CA.
        </p>
        <pre class="example" data-include="examples/example-contract.json" title="Example DTC (JSON) (non-normative)"></pre>
      </section>
      <section id="dtc-representations-jsonld">
        <h3>JSON-LD</h3>

        <p>We use the <a href="https://w3id.org/reshare/ontology/0.3/">ReShare ontology v0.3</a>, which we describe in Section <a href="#reshare-ontology"></a>, for defining the semantics of the JSON structure in a JSON-LD [[JSON-LD11]] representation for DTCs.</p>

        <p>
          Instead of defining a schema for the JSON-LD representation of DTCs, we specify a procedure to transform a JSON representation of a DTC into a JSON-LD representation, and a procedure to transform a JSON-LD representation to a JSON representation.
        </p>

        <section class="notoc">
          <h2>JSON to JSON-LD</h2>

          <p>To raise a valid JSON DTC serialization to JSON-LD, the following transformation steps MUST be conducted:
          </p>
          <ol>
            <li>Add the static <code>@context</code> object</li>
            <li>Add <code>@type</code> keywords to the non-literal (sub-)objects</li>
            <li>Add the contract base IRI to the <code>@context</code> object as an IRI prefix</li>
            <li>Add <code>@id</code> keywords to the non-literal sub-objects
          </ol>
          <p>
            Details about the steps are presented in the following and MUST be followed when creating a JSON-LD representation of a DTC.
          </p>
          <p class="note">In the following examples, the misuse of the triple-dot notation denotes that the rest of the JSON structure is not changed.
            As it is only used in informative examples, it does not violate the normative character of this section.</p>
          <ol>
            <li>The following static <code>@context</code> object (corresponding to version 0.3 of the ReShare ontology)
              MUST be added to the root of the DTC object:
              <pre class="example" data-include="examples/dtc-jsonld-context.jsonld" title="DTC JSON-LD context"></pre>
            </li>
            <li>
              <p>
                The following (sub-)objects of the DTC object MUST be typed explicitly with the following types by adding a <code>@type</code> attribute to their root-level attributes:
              </p>
              <table id="tab-jsonld-typing" class="customtable">
                <thead>
                  <tr>
                    <th>JSON object</th>
                    <th>Type IRI</th>
                  </tr>
                </thead>
                <tr>
                  <td>Root DTC object</td>
                  <td><code>fc:DTC</code></td>
                </tr>
                <tr>
                  <td>Each entry of <a data-lt="dtc-facts">facts</a></td>
                  <td><code>fc:Fact</code></td>
                </tr>
                <tr>
                  <td><a data-lt="dtc-sender">sender</a></td>
                  <td><code>fc:Sender</code></td>
                </tr>
                <tr>
                  <td><a data-lt="dtc-receiver">receiver</a></td>
                  <td><code>fc:Receiver</code></td>
                </tr>
                <tr>
                  <td><a data-lt="dtc-senderSig">senderSig</a></td>
                  <td><code>fc:Signature</code></td>
                </tr>
                <tr>
                  <td><a data-lt="dtc-receiverSig">receiverSig</a></td>
                  <td><code>fc:Signature</code></td>
                </tr>

              </table>
              <p class="note">
                All other contract fields do not need to be typed, as they are represented as literals in JSON-LD, and are typed through the <code>@context</code> objects.
              </p>
              <p>
                The assignment of <code>@type</code> attributes is illustrated with the following example.
              </p>
              <pre class="example" id="typing-a-dtc" title="Explicitly typing a DTC using @type (non-normative)" data-include="examples/typing-a-dtc.jsonld"></pre>
            </li>
            <li>
              <p>
                An IRI prefix for the keyword <code>contract</code> MUST be added to the <code>@context</code> object.
                The prefix MUST be set to the <a data-lt="dtc-baseIRI">baseIRI</a> of the contract.
              </p>
              <p>
                The step is illustrated with the following example.
                Note that the <code>baseIRI</code> attribute existed beforehand. Its value is simply copied to the IRI prefix definition.
              </p>
              <pre class="example" id="adding-baseiri-prefix" title="Adding the base IRI of the DTC to its context as an IRI prefix (non-normative)" data-include="examples/adding-baseiri-prefix.jsonld"></pre>
            </li>
            <li>
              <p>
                The following (sub-)objects of the DTC object MUST be made identifiable with the following <a>IRIs</a>
                (relative to the root DTC IRI) by adding a <code>@id</code> attribute to their root-level attributes:
              </p>
              <table id="tab-jsonld-ids" class="customtable">
                <thead>
                  <tr>
                    <th style="min-width: 15em;">JSON object</th>
                    <th>Resource IRI</th>
                  </tr>
                </thead>
                <tr>
                  <td>Each entry of <a data-lt="dtc-facts">facts</a></td>
                  <td>
                    <code>contract:fact-&lt;i&gt;</code>, where <code>&lt;i&gt</code> is the index of the entry within <a data-lt="dtc-facts">facts</a> when sorted lexicographically by <a data-lt="dtc-facts-factID">factID</a> (starting with <code>contract:fact-0</code>)
                  </td>
                </tr>
                <tr>
                  <td><a data-lt="dtc-sender">sender</a></td>
                  <td><code>contract:sender</code></td>
                </tr>
                <tr>
                  <td><a data-lt="dtc-receiver">receiver</a></td>
                  <td><code>contract:receiver</code></td>
                </tr>
                <tr>
                  <td><a data-lt="dtc-senderSig">senderSig</a></td>
                  <td><code>contract:senderSig</code></td>
                </tr>
                <tr>
                  <td><a data-lt="dtc-receiverSig">receiverSig</a></td>
                  <td><code>contract:senderSig</code></td>
                </tr>
              </table>
              <p class="note">
                All other contract fields are not assigned an IRI, as they are represented as literals in JSON-LD, and thus do not have their own IRIs.
                Instead, they can be queried through the data properties of the DTC resource.
              </p>
              <p>The assignment of <code>@id</code> attributes is illustrated with the following example.</p>
              <pre class="example" id="adding-compact-iris" title="Explicitly adding IRIs to the DTC subcomponents using @id (non-normative)" data-include="examples/adding-compact-iris.jsonld"></pre>
            </li>
          </ol>
          <p>In the following, we give the example of a DTC represented in JSON-LD, where the static part of the <code>@context</code> object is omitted for readability.
          </p>
          <pre id="example-contract-jsonld" class="example" data-include="examples/example-contract-short.jsonld" title="Example DTC (JSON-LD) (non-normative)"></pre>
        </section>

        <section class="notoc">
          <h2>JSON-LD to JSON</h2>

          <p>To transfer a JSON-LD representation of a DTC to a JSON representation, one MUST execute the following steps:</p>

          <ol>
            <li>Build the <code>@context</code> object by adding a <code>contract</code> IRI prefix to the static <code>@context</code> object from the JSON-to-JSON-LD transformation by copying the IRI of the DTC,
              similarly to step 3 of the JSON-to-JSON-LD transformation.
            </li>
            <li>Use the JSON-LD <a href="https://www.w3.org/TR/json-ld11-api/#compaction-algorithm">compaction algorithm</a> [[JSON-LD11-API]] to compact the JSON-LD document together with the context built in Step 1.</li>
            <li>Remove all <code>@type</code>, <code>@id</code>, and <code>@context</code> attributes.
              <span class="note">Note: The <code>baseIRI</code> of the DTC is unaffected by this, as it is aliased as <code>@id</code>, and thus is not removed!</span>
            </li>
          </ol>
        </section>
      </section>
    </section>
    <section id="dtc-signatures">
      <h2>Signature Creation & Verification</h2>
      <div class="tlcontent">
        <p>
          A valid DTC MUST always contain two signatures, one by the <a>sender</a>, and one by the <a>receiver</a>.
          These signatures constitute a central component of the trust chain of a DTC, connecting the information included in DTCs (e.g., the checksums in <a data-lt="dtc-facts">facts</a>) to the public keys of <a>sender</a>
          and <a>receiver</a>.
          The signatures are included in the DTC itself in the <a data-lt="dtc-senderSig">senderSig</a> and <a data-lt="dtc-receiverSig">receiverSig</a> fields (see <a href="#dtc-data-structure"></a>).
        </p>
        <p>
          The processes of creating and verifying DTC signatures, which are specified in the following, are the same for any party (<a>sender</a> or <a>receiver</a>).
          Thus, we only consider the <a>sender</a> in the following.
          For <a>receiver</a> signatures, analogous steps apply.
        </p>
        <p>
          Each party (<a>sender</a> and <a>receiver</a>) MUST have an RSA public/private key pair which they use for creating DTC signatures.
          The public key of the key pair used to create DTC signatures MUST be included in the <code>cert</code>
          property of the respective identity field of the DTC, i.e., <a data-lt="dtc-sender">sender</a> or <a data-lt="dtc-receiver">receiver</a> (see <a href="#dtc-data-structure"></a>).
        </p>
      </div>

      <section id="dtc-signatures-overview">
        <h3>Overview</h3>

        <div class="tlcontent">
          <p>
            The processes of signature creation and verification can be divided into three low-level processes:
            A <a href="#dtc-signatures-preprocessing">pre-processing pipeline</a> for generating a normalized binary serialization of a DTC (further described in Section <a href="#dtc-signatures-preprocessing"></a>), and both a <a href="#dtc-signatures-creation">signature creation</a> and <a href="#dtc-signatures-verification">verification</a> process based on the pre-processed form of a DTC (further described in Sections <a href="#dtc-signatures-creation"></a> and <a href="#dtc-signatures-verification"></a> respectively).
          </p>
          <p>
            The integration of said low-level processes into the high-level processes of signature creation and verification is visualized in the two figures below.
          </p>
          <figure id="fig-dtc-sigproc-pipeline-creation" style="text-align: center;">
            <object data="figures/signature-process-pipeline-creation.svg" style="width:80%;" type="image/svg+xml" aria-describedby="fig-dtc-sigproc-pipeline-creation"></object>
            <p id="fig-dtc-sigproc-pipeline-creation-alt">
              DTC signature creation process (high-level)
            </p>
            <figcaption>
              The high-level process of creating a DTC signature.
              The DTC is pre-processed first before creating the DTC signature using the signer's private key.
            </figcaption>
          </figure>
          <figure id="fig-dtc-sigproc-pipeline-verification" style="text-align: center;">
            <object data="figures/signature-process-pipeline-verification.svg" style="width: 75%;" type="image/svg+xml" aria-describedby="fig-dtc-sigproc-pipeline-verification"></object>
            <p id="fig-dtc-sigproc-pipeline-verification-alt">
              DTC signature verification process (high-level)
            </p>
            <figcaption>
              The high-level process of verifying a DTC signature.
              The DTC is pre-processed first before verifiying the given DTC signature using the signer's public key.
            </figcaption>
          </figure>
        </div>

      </section>


      <section id="dtc-signatures-preprocessing">
        <h3>Pre-Processing</h3>

        <div class="tlcontent">
          <p>
            The DTC pre-processing pipeline, as visualized below, consists of four steps and starts with the implementation-dependent internal representation of the DTC.
          </p>
          <figure id="fig-dtc-sigproc-preprocessing" style="text-align: center;">
            <object data="figures/signature-process-preprocessing.svg" style="width:80%;" type="image/svg+xml" aria-describedby="fig-dtc-sigproc-preprocessing"></object>
            <p id="fig-dtc-sigproc-preprocessing-alt">
              The pre-processing steps for creating and verifying DTC signatures </p>
            <figcaption>
              The pre-processing steps for creating and verifying DTC signatures.
              The internal DTC is serialized as specified by the JSON DTC represenation, pruned by removing unsigned material, normalized, and encoded as a <a href="https://datatracker.ietf.org/doc/html/rfc3629">UTF-8</a>
              string [[RFC3629]].
            </figcaption>
          </figure>
          <p>
            The four pre-processing steps MUST be executed as follows in order to uniquely serialize and normalize the DTC.
          </p>
          <ol>
            <li>
              <b>Serialize:</b>
              The (potentially incomplete) DTC MUST be serialized as JSON according to Section <a href="#dtc-representations"></a>.
              This representation MUST match the schema of a <a href="schemas/dtc_only_signatures_missing.schema.json" class="external" target="_blank">partial DTC, where only the two signatures may be missing</a>, as defined in Section <a href="#dtc-representations"></a>.
            </li>
            <li>
              <b>Remove unsigned content:</b>
              To not impose a dependency on the ordering of signatures by the parties, pre-existing signature material MUST NOT be included in the signature.
              Thus, both the <a data-lt="dtc-senderSig">senderSig</a> and <a data-lt="dtc-receiverSig">receiverSig</a>
              fields (if existing) MUST be removed in this step.
            </li>
            <li>
              <b>Normalize:</b>
              First, in order to achieve a unique order of the included facts, the <a data-lt="dtc-facts">facts</a>
              array MUST be sorted by the ascending lexicographic order of the <a data-lt="dtc-facts-factID">factID</a>
              subproperty in <a href="https://datatracker.ietf.org/doc/html/rfc3629">UTF-8</a> encoding [[RFC3629]].
              Afterward, the JSON document MUST be canonicalized according to the <a href="https://datatracker.ietf.org/doc/html/rfc8785">JSON Canonicalization Scheme (JCS)</a> [[RFC8785]].
            </li>
            <li>
              <b>Encode:</b>
              To discretize the string encoding of the normalized JSON contract, it MUST be encoded using <a href="https://datatracker.ietf.org/doc/html/rfc3629">UTF-8</a> [[RFC3629]].
            </li>
          </ol>
        </div>

      </section>

      <section id="dtc-signatures-creation">
        <h3>Signature Creation</h3>

        <div class="tlcontent">
          <figure id="fig-dtc-sigproc-creation" style="text-align: center;">
            <object data="figures/signature-process-creation.svg" style="width: 70%;" type="image/svg+xml" aria-describedby="fig-dtc-sigproc-creation"></object>
            <p id="fig-dtc-sigproc-creation-alt">
              The process of creating a DTC signature, based on its pre-processed form.
            </p>
            <figcaption>
              The process of creating a DTC signature, based on its pre-processed form.
              Using said pre-processed DTC and its own private key, the signing party creates an RSA signature, which is encoded as <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-4">Base64</a> [[RFC4648]].
            </figcaption>
          </figure>
          <p>
            The signature MUST be created using the pre-processed form of the DTC as described in Section <a href="#dtc-signatures-preprocessing"></a> as the input to the <a href="https://datatracker.ietf.org/doc/html/rfc8017#section-8.1.1"><code>RSASSA-PSS-SIGN</code></a>
            operation specified in <a href="https://datatracker.ietf.org/doc/html/rfc8017">PKCS #1</a> [[RFC8017]].
          </p>
          <p>
            For the <a href="https://datatracker.ietf.org/doc/html/rfc8017#section-9.1.1"><code>EMSA-PSS-ENCODE</code></a>
            encoding operation used in the <a href="https://datatracker.ietf.org/doc/html/rfc8017#section-8.1.1"><code>RSASSA-PSS-SIGN</code></a>
            operation, the following parameters MUST be selected:
          </p>
          <ul>
            <li>
              Hash function (<code>Hash</code>): SHA-256 [[FIPS-180-4]]
            </li>
            <li>
              Mask generation function (<code>MGF</code>): <a href="https://datatracker.ietf.org/doc/html/rfc8017#appendix-B.2.1">MGF1</a> [[RFC8017]]
            </li>
            <li>
              Salt length (<code>sLen</code>): 32 (=<code>hLen</code>, i.e., the length of a SHA-256 hash in octets)
            </li>
          </ul>
          <p>
            The binary output of the <code>RSASSA-PSS</code> signature creation primitive MUST be encoded as <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-4">Base64</a> [[RFC4648]].
          </p>
          <p>
            The encoded signature can be used as the <code>sig</code> subfield of the <a data-lt="dtc-senderSig">senderSig</a> or <a data-lt="dtc-receiverSig">receiverSig</a> DTC fields (the field associated with the signer), as specified in Section <a href="#dtc-data-structure"></a>.
          </p>
        </div>
      </section>

      <section id="dtc-signatures-verification">
        <h3>Signature Verification</h3>

        <div class="tlcontent">
          <figure id="fig-dtc-sigproc-verification" style="text-align: center;">
            <object data="figures/signature-process-verification.svg" style="width: 70%;" type="image/svg+xml" aria-describedby="fig-dtc-sigproc-verification"></object>
            <p id="fig-dtc-sigproc-verification-alt">
              The process of verifying a DTC signature, based on its pre-processed form.
            </p>
            <figcaption>
              The process of verifying a DTC signature, based on its pre-processed form.
              Requires said pre-processed DTC, the DTC signature encoded as <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-4">Base64</a> [[RFC4648]], and the signing party's public key.
              The signature is first decoded into a binary form, and then verified using the pre-processed DTC and the public key.
            </figcaption>
          </figure>
          <p>
            To verify a given signature, as included in the <a data-lt="dtc-senderSig">senderSig</a> or <a data-lt="dtc-receiverSig">receiverSig</a> DTC fields (see <a href="#dtc-data-structure"></a>), the encoded signature (here: <code>senderSig</code>) MUST be decoded as <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-4">Base64</a> [[RFC4648]].
          </p>
          <p>The DTC MUST be pre-processed according to <a href="#dtc-signatures-preprocessing"></a>.</p>
          <p>Together with the pre-processed DTC, and the public key associated with the signature, the signature MUST then be verified according to the <a href="https://datatracker.ietf.org/doc/html/rfc8017#section-8.1.2"><code>RSASSA-PSS-VERIFY</code></a>
            operation as specified in <a href="https://datatracker.ietf.org/doc/html/rfc8017">PKCS #1</a> [[RFC8017]].
          </p>
          <p>For the <a href="https://datatracker.ietf.org/doc/html/rfc8017#section-9.1.2"><code>EMSA-PSS-VERIFY</code></a>
            operation, which is used in the <a href="https://datatracker.ietf.org/doc/html/rfc8017#section-8.1.2"><code>RSASSA-PSS-VERIFY</code></a>
            operation, the same parameters as for <a href="https://datatracker.ietf.org/doc/html/rfc8017#section-9.1.1"><code>EMSA-PSS-ENCODE</code></a> (see <a href="#dtc-signatures-creation"></a>) MUST be used.
          </p>
        </div>
      </section>
    </section>

  </section>
  <section id="reshare-ontology">
    <h2>The ReShare Ontology</h2>

    <div id="download-serialization">
      <dl>
        <dt>Standalone documentation:</dt>
        <dd>
          <a href="https://w3id.org/reshare/ontology/0.3" target="_blank"><img src="https://img.shields.io/badge/Documentation-v0.3-blue.svg" alt="Documentation v0.3"></a>
        </dd>
        <dt>Revision:</dt>
        <dd>0.3</dd>
        <dt>Download serialization:</dt>
        <dd><span><a href="https://w3id.org/reshare/ontology/0.3/ontology.jsonld" target="_blank"><img src="https://img.shields.io/badge/Format-JSON_LD-blue.svg" alt="JSON-LD" /></a>
          </span><span><a href="https://w3id.org/reshare/ontology/0.3/ontology.rdf" target="_blank"><img src="https://img.shields.io/badge/Format-RDF/XML-blue.svg" alt="RDF/XML" /></a>
          </span><span><a href="https://w3id.org/reshare/ontology/0.3/ontology.nt" target="_blank"><img src="https://img.shields.io/badge/Format-N_Triples-blue.svg" alt="N-Triples" /></a>
          </span><span><a href="https://w3id.org/reshare/ontology/0.3/ontology.ttl" target="_blank"><img src="https://img.shields.io/badge/Format-TTL-blue.svg" alt="TTL" /></a> </span></dd>
        <dt>Visualization:</dt>
        <dd><a href="webvowl/index.html#" target="_blank"><img src="https://img.shields.io/badge/Visualize_with-WebVowl-blue.svg" alt="Visualize with WebVowl" /></a>
        </dd>
        <!-- <dt>Evaluation:</dt><dd><a href="OOPSEvaluation/OOPSeval.html#" target="_blank"><img src="https://img.shields.io/badge/Evaluate_with-OOPS! (OntOlogy Pitfall Scanner!)-blue.svg" alt="Evaluate with OOPS!" /></a></dd> -->
      </dl>
    </div>

    <!-- Introduction text -->
    <p>
      To enable the interpretation of DTCs as Linked Data, we propose the <em>ReShare ontology</em>.
      The ontology defines the properties and classes used in the <a href="#dtc-representations-jsonld">JSON-LD representation</a> of DTCs as specified in Section <a href="#dtc-representations"></a>.
    </p>

    <section>
      <h3>Overview</h3>
      <div id="overview" class="widoco"></div>
    </section>

    <!-- Normally there is a div#crossref the following three sections. If something breaks w.r.t. Widoco, this may be the cause. -->
    <section id="sec-classes">
      <h3>Classes</h3>

      <!-- Classes automatically imported from Widoco -->
      <div id="classes" class="widoco"></div>
    </section>

    <section>
      <h3>Object Properties</h3>
      <!-- Object properties automatically imported from Widoco -->
      <div id="objectproperties" class="widoco"></div>

    </section>
    <section>
      <h3>Data Properties</h3>
      <!-- Data properties automatically imported from Widoco -->
      <div id="dataproperties" class="widoco"></div>
    </section>

    <!-- Widoco legend -->
    <section class="notoc" id="legend">
      <h3>Legend</h3>
      <div class="widoco entity">
        <sup class="type-c" title="Classes">c</sup>: Classes <br>
        <sup class="type-op" title="Object Properties">op</sup>: Object Properties <br>
        <sup class="type-dp" title="Datatype Properties">dp</sup>: Datatype Properties <br>
        <sup class="type-ni" title="Named Individuals">ni</sup>: Named Individuals
      </div>
    </section>
  </section>
  <section id="dtc-generation-and-verification">
    <h2>DTC Generation & Verification</h2>
    <div class="tlcontent">
      <p>
        Two core mechanisms are defined as part of ReShare:
      </p>
      <ul>
        <li>A <a href="#dtcgenver-generation"><em>generation mechanism</em></a> to generate valid DTCs between parties.
        </li>
        <li>A <a href="#dtcgenver-verification"><em>verification mechanism</em></a> to reliably verify both the validity of the dtc and the contained resource checksums.</li>
      </ul>

      <p>
        Any implementation MUST implement the <a href="#dtcgenver-verification">verification mechanism</a> mechanism according to Section <a href="#dtcgenver-verification"></a>.
      </p>

      <p>
        The <a href="#dtcgenver-generation">generation mechanism</a>, which is specified in Section <a href="#dtcgenver-generation"></a>, follows a client-server-paradigm.
        To allow for application-dependent lightweight implementations, the client and server parts of the <a href="#dtcgenver-generation">generation mechanism</a> MAY not be implemented.
        The following combinations are possible:
      <table class="customtable">
        <thead>
          <tr>
            <th>Server implemented</th>
            <th>Client implemented</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Yes</td>
            <td>Yes</td>
            <td>Full implementation</td>
          </tr>
          <tr>
            <td>Yes</td>
            <td>No</td>
            <td>Only supports <a>sender</a> role & DTC verification</td>
          </tr>
          <tr>
            <td>No</td>
            <td>Yes</td>
            <td>Only supports <a>receiver</a> role & DTC verification</td>
          </tr>
          <tr>
            <td>No</td>
            <td>No</td>
            <td>Only supports DTC verification</td>
          </tr>
        </tbody>
      </table>
      </p>

    </div>

    <section id="dtcgenver-generation">
      <h3>DTC Generation Handshake</h3>

      <div class="tlcontent">
        <p>
          The DTC generation mechanism constitutes a handshake, in which <a>sender</a> and <a>receiver</a> jointly create and sign a DTC in a client-server paradigm.
        </p>

        <p>
          We specify two versions of this generation handshake:
          A complete 3-way version, which can be carried out completely in parallel to the underlying data transmission,
          and an abbreviated 2-way handshake, which can be used if the <a>receiver</a> has access to the complete underlying data of the DTC (i.e., the data transmission has to be completed already).
        </p>

        <p>
          The benefits of the independence of DTC generation to the data transmission are expected to outweigh the effects of the increased overhead in most use cases.
          Thus, we consider the complete 3-way handshake the default handshake version.
          A brief elaboration on this discussion can be found in Section <a href="#considerations-2or3wayhs"></a>.
        </p>

        <p>
          We do not specify any mechanism to separate handshake versions or negotiate the handshake version.
          Instead, such a mechanism MAY be implemented on a lower layer (e.g., by using HTTP content negotiation or using two ports for separating the two handshake versions).
        </p>

      </div>

      <section id="dtcgenver-generation-overview" class="informative">
        <h2>Overview</h2>

        <p>
          The specification of the DTC generation mechanism is divided into the following components:
        </p>
        <ul>
          <li>
            <i>Client and server implementations:</i>
            Define the behavior which implements the handshake itself, depending on the handshake version (i.e.,
            complete or abbreviated).
            The client and server implementations receive messages from the abstraction components for the lower-layer communication stack, build new messages, and send these messages to the abstraction components of the communication stack.
          </li>
          <li>
            <i>Helper components:</i>
            We define a <i>message builder</i>, a <i>message validator</i>, and an <i>error message builder</i>, which are used by the client and server implementations to validate and build message objects.
          </li>
          <li>
            <i>Communication abstraction components:</i>
            Directly communicate with the deployment-specific communication stack, such that the client and server implementations can be transparent w.r.t. the underlying communication stack.
          </li>
        </ul>

        <p>The DTC generation components are visualized in the following figure.</p>

        <figure id="fig-dtcgen-overview" style="text-align: center;">
          <object data="figures/dtc-generation-overview.svg" style="width:100%;" type="image/svg+xml" aria-describedby="fig-dtcgen-overview"></object>
          <p id="fig-dtcgen-overview-alt">
            Overview of the components of the DTC generation mechanism.
          </p>
          <figcaption>
            A schematic overview of the components of the DTC generation mechanism.
          </figcaption>
        </figure>

      </section>

      <section id="dtcgenver-generation-complete">
        <h4>Complete (3-way) Handshake</h4>

        <div class="tlcontent">
          <p>
            The complete DTC generation handshake consists of the following three steps, which are described in detail in the following:
          </p>
          <ol>
            <li>
              The <a>receiver</a> initiates the DTC generation by stating its identity and the set of facts to be included in the DTC.
              The current version of the DTC only contains the <a data-lt="dtc-receiver">receiver</a>, <a data-lt="dtc-facts">facts</a> (only <a>IRIs</a>, no checksums), and <a data-lt="dtc-customContent"><code>receiverCustomContent</code></a> fields.
            </li>
            <li>
              Upon receipt of the initiation message, the <a>sender</a> compiles and signs the contract.
              The current version of the DTC is only missing the <a data-lt="dtc-receiverSig">receiverSig</a> field.
            </li>
            <li>
              Upon receipt of the <a>sender</a>-signed (partial) DTC, the <a>receiver</a> verifies the current state of the DTC and signs it afterward.
              The DTC is now complete and valid, and is sent back to the <a>sender</a> for mutual storage.
            </li>
          </ol>

          <p>
            The following figure gives an overview of the handshake messages and computations.
            Note that only the differential message contents are listed, as the previously existing DTC content is carried over to the next messages.
            The caption includes a mapping from the message abbreviations used in the figure to the message identifiers defined in Section <a href="#dtcgenver-generation-msgids"></a>.
          </p>

          <figure id="fig-dtc-generation-handshake" style="text-align:center">
            <object data="figures/contract-generation-handshake.svg" style="width:100%;" type="image/svg+xml" aria-describedby="fig-dtc-generation-handshake"></object>
            <p id="fig-contract-generation-handshake-alt">
              The 3-way contract generation handshake </p>
            <figcaption>
              A message diagram of the 3-way contract generation handshake, initiated by the <a>receiver</a> (<span class="fig-agent">R</span>).
              Upon a request (<i>R1</i>=<code>ContractRequest</code>), the <a>sender</a> (<span class="fig-agent">S</span>) assembles the DTC, signs it, and sends it to the <a>receiver</a> (<i>S1</i>=<code>SenderContract</code>).
              Finally, the <a>receiver</a> verifies and signs the DTC, and sends its own signature to the <a>sender</a>
              (<i>R2</i>=<code>ReceiverContract</code>).
            </figcaption>
          </figure>

          <p>
            In the following, we define the behavior of client and server implementations in detail.
          </p>

          <section class="notoc">
            <h2>Handshake Initiation (Client-side)</h2>

            <p>
              The client is responsible for initiating the DTC generation handshake.
              For this, an appropriate user interface (manual trigger) or interface to the data-sharing system (automatic trigger) SHOULD be implemented.
            </p>

            <!-- Initiation -->
            <p>
              To initiate the DTC generation, the client MUST first compile a partial DTC only consisting of the <a data-lt="dtc-receiver">receiver</a>, the <a data-lt="dtc-facts">facts</a>, and the (optional) <a data-lt="dtc-customContent"><code>receiverCustomContent</code></a> fields.
              The content of the <a data-lt="dtc-receiver">receiver</a> and <a data-lt="dtc-customContent"><code>receiverCustomContent</code></a> fields MUST comply with the contents specified in Section <a href="#dtc-data-structure"></a>.
              The content of <a data-lt="dtc-facts">facts</a> MUST comply with its definition in Section <a href="#dtc-data-structure"></a>, except that the <a data-lt="dtc-facts-requestedID">requestedID</a>, <a data-lt="dtc-facts-alg">&lt;alg&gt;</a>, and <a data-lt="dtc-facts-serialization">serialization</a>
              sub-fields MUST NOT be present for any entry.
            </p>
            <p>
              The client then MUST use the partial DTC to build the <code>ContractRequest</code> message by passing the partial DTC to the message builder defined in Section <a href="#dtcgenver-generation-msgbuilder"></a>, and use the <a>outgoing message interface</a> (see Section <a href="#dtcgenver-generation-protocol"></a>) to send it to the server.
            </p>

          </section>

          <section class="notoc">
            <h2>Client-side Incoming Message Handling</h2>

            <p>
              Once the client implementation is called by the <a>incoming message handler</a> (see Section <a href="#dtcgenver-generation-protocol"></a>), the following procedure MUST be carried out.
            </p>

            <p>Start with step 1.
              If no "continue with step x" phrase is hit, the procedure is finished.</p>

            <ol>
              <li>
                The client MUST pass the received message, together with an arbitrarily ordered list of the tuples <code>(id,schema)</code> of all <a>error message identifiers</a> (defined in Section <a href="#dtcgenver-generation-msgids"></a>) and their respective schemas (defined in Section <a href="#dtcgenver-generation-msgschemas"></a>), to the message validator (see Section <a href="#dtcgenver-generation-msgvalidator"></a>).
                If the validation returns <code>None</code>, continue with step 2.
                If the validation returns one of the error message identifiers, the implementation MAY behave arbitrarily (see the discussion and behavior recommendation in Section <a href="#dtcgenver-generation-errors"></a>).
              </li>
              <li>
                The client MUST pass the message, along with the schema for an <code>S1</code> message (defined in Section <a href="#dtcgenver-generation-msgschemas"></a>), to the message validator (see Section <a href="#dtcgenver-generation-msgvalidator"></a>).
                If <code>None</code> is returned by the message validator, the client SHOULD send an <code>UnknownMessage</code> error to the server according to Section <a href="#dtcgenver-generation-errors"></a>.
                If the validator returns <code>S1</code>, continue with step 3.
              </li>
              <li>
                The client SHOULD check whether the received <code>S1</code> message belongs to an unanswered previous <code>ContractRequest</code> message.
                The implementation of this check is not further specified, but MAY be implemented by matching HTTP requests and responses (see Section <a href="#dtcgenver-generation-protocol"></a> for a specification of the protocol stack) or by implementing a custom caching mechanism.
                If the check fails, the client SHOULD send an <code>UnexpectedSenderContract</code> error to the server according to Section <a href="#dtcgenver-generation-errors"></a>.
                If the check succeeds, or if no check was executed, continue with step 4.
              </li>
              <li>
                <p>
                  The client MUST extract and parse the partial DTC contained in the <code>content</code> attribute of the JSON message, and verify </p>
                <ul>
                  <li>that the sender's identity (in <a data-lt="dtc-sender">sender</a>) is as expected</li>
                  <li>
                    that the sender's public key certificate (in <a data-lt="dtc-sender">sender</a>) is valid and trusted <p class="note">
                      This step SHOULD include checking whether the public key certificate has been issued for the authority identified by the <a>IRI</a> contained in the <a data-lt="dtc-sender">sender</a> field.
                      We further discuss this verification step in Section <a href="#considerations-iricertlink"></a>.
                    </p>
                  </li>
                  <li>that the sender's signature (in <a data-lt="dtc-senderSig">senderSig</a>) is valid by verifying the signature according to Section <a href="#dtc-signatures-verification"></a>.
                    The sender's public key contained in the public key certificate in <a data-lt="dtc-sender">sender</a> MUST be used for the verification procedure.</li>
                  <li><i>(optional)</i> that the <a>fact</a> checksums contained in <a data-lt="dtc-facts">facts</a> are valid.
                    This is dependent on a completed data transaction and an interface to the data within the client-side handshake implementation, and thus, is not mandatory to implement.</li>
                </ul>
                If any of these verifications fail, the client MUST send an <code>InvalidSenderContract</code> error message to the server according to Section <a href="#dtcgenver-generation-errors"></a>, and SHOULD consider the <code>ContractRequest</code> message, to which the <code>S1</code> message was matched, as unanswered, such that the server can retry sending a valid matching <code>S1</code> message.
                If all of the verifications succeeded, continue with step 5.
              </li>
              <li>
                The client MUST create a signature according to Section <a href="#dtc-signatures-creation"></a> using the partial DTC from the <code>S1</code> message and the private key associated with the public key included in the public key certificate in the <a data-lt="dtc-receiver">receiver</a> field, and add it as the <a data-lt="dtc-receiverSig">receiverSig</a> field according to Section <a href="#dtc-data-structure"></a>.
                The client SHOULD accept the complete DTC and SHOULD forward it so a DTC storage system.
                Finally, the client MUST build the <code>R2</code> message by passing the now-complete DTC to the message builder (see Section <a href="#dtcgenver-generation-msgbuilder"></a>), and use the <a>outgoing message interface</a> (see Section <a href="#dtcgenver-generation-protocol"></a>) to send it to the server.
              </li>
            </ol>
          </section>

          <section class="notoc">
            <h2>Server-side Incoming Message Handling</h2>

            <p>
              Once the server implementation is called by the <a>incoming message handler</a> (see Section <a href="#dtcgenver-generation-protocol"></a>), the following procedure MUST be carried out.
            </p>

            <p>Start with step 1.
              If no "continue with step x" phrase is hit, the procedure is finished.</p>

            <ol>
              <li>
                The server MUST pass the received message, together with an arbitrarily ordered list of the tuples <code>(id,schema)</code> of all <a>error message identifiers</a> (defined in Section <a href="#dtcgenver-generation-msgids"></a>) and their respective schemas (defined in Section <a href="#dtcgenver-generation-msgschemas"></a>), to the message validator (see Section <a href="#dtcgenver-generation-msgvalidator"></a>).
                If the validation returns <code>None</code>, continue with step 2.
                If the validation returns one of the error message identifiers, the implementation MAY behave arbitrarily (see the discussion and behavior recommendation in Section <a href="#dtcgenver-generation-errors"></a>).
              </li>
              <li>
                The server MUST pass the message, together with the list containing the <code>ContractRequest</code> and <code>R2</code> message schemas (in this order, defined in Section <a href="#dtcgenver-generation-msgschemas"></a>) to the message validator (see <a href="#dtcgenver-generation-msgvalidator"></a>).
                If the validator returns <code>None</code>, the server MUST send an <code>UnknownMessage</code> error to the client according to Section <a href="#dtcgenver-generation-errors"></a>.
                If the validator returns <code>ContractRequest</code>, continue with step 3.
                If the validator returns <code>R2</code>, continue with step 6.
              </li>
              <li>
                The server MUST parse the partial DTC in the <code>contract</code> attribute of the JSON message.
                Then, the server MAY verify that the client is authorized to request the DTC for the <a>facts</a>
                contained in the <a data-lt="dtc-facts">facts</a> field.
                <p class="note">
                  Such an access-control mechanism is not specified, but could be implemented on a lower layer (e.g.,
                  using the HTTP Authorization header).
                  Therefore, error handling for access control should also be implemented on a lower layer.
                </p>
                Subsequently, the server compiles the DTC.
                Therefore, it MUST carry out the following steps on the received partial DTC in any order:
                <ul>
                  <li>
                    The server adds the <a data-lt="dtc-sender">sender</a> field with its own information, such that the content complies with Section <a href="#dtc-data-structure"></a>.
                  </li>
                  <li>
                    The server looks up or computes the checksums for the <a>facts</a> identified by the <a>IRIs</a>
                    contained in the <a data-lt="dtc-facts-factID">factID</a> sub-fields of the entries of <a data-lt="dtc-facts">facts</a>.
                    During this process, the server MAY resolve some of the <a>IRIs</a> to concretized <a>IRIs</a> (see the documentation <a data-lt="dtc-facts-requestedID">requestedID</a> for details).
                    In this case, the server MUST copy the content of <a data-lt="dtc-facts-factID">factID</a> to <a data-lt="dtc-facts-requestedID">requestedID</a>, and subsequently overwrite the content of <a data-lt="dtc-facts-factID">factID</a> with the new <a>IRI</a> in accordance with Section <a href="#dtc-data-structure"></a>.
                    It then adds each checksum to the <a data-lt="dtc-facts-alg"><code>&lt;alg&gt;</code></a> sub-field of the respective <a data-lt="dtc-facts">facts</a> entry in accordance with Section <a href="#dtc-data-structure"></a>.
                    As specified in Section <a href="#dtc-data-structure"></a>, the checksum is associated with a specific serialization of the <a>fact</a>.
                    The server MUST add the serialization identifier to the <a data-lt="dtc-facts-serialization">serialization</a> sub-field of each entry of <a data-lt="dtc-facts">facts</a> according to Section <a href="#dtc-data-structure"></a>.
                  </li>
                  <li>
                    The server creates a timestamp of its current time and adds it to the <a data-lt="dtc-timestamp">timestamp</a> field according to Section <a href="#dtc-data-structure"></a>.
                  </li>
                  <li>
                    The server creates a base <a>IRI</a>, which can be used to uniquely identify the created DTC.
                    For this, the server MAY use the previously created timestamp, or any other custom identification scheme.
                    The server then adds the <a>IRI</a> to the <a data-lt="dtc-baseIRI">baseIRI</a> field according to Section <a href="#dtc-data-structure"></a>.
                  </li>
                  <li>
                    <i>(Optional)</i>
                    The server adds content to the <a data-lt="dtc-customContent"><code>senderCustomContent</code></a>
                    field according to <a href="#dtc-data-structure"></a>.
                  </li>
                </ul>
                <p>Continue with step 4.</p>
              </li>
              <li>
                The server creates a signature according to Section <a href="#dtc-signatures-creation"></a> for the compiled DTC and the private key associated with the public key included in the public key certificate in the <a data-lt="dtc-sender">sender</a> field.
                The server then adds it as the <a data-lt="dtc-senderSig">senderSig</a> field according to Section <a href="#dtc-data-structure"></a>.
                Continue with step 5.
              </li>
              <li>
                The server MUST build the <code>S2</code> message by passing the compiled (partial) DTC to the message builder (see Section <a href="#dtcgenver-generation-msgbuilder"></a>), and MUST then use the <a>outgoing message interface</a> (see Section <a href="#dtcgenver-generation-protocol"></a>) to send the resulting message to the client.
              </li>
              <li>
                The server MUST parse the DTC contained in the <code>contract</code> field of the JSON message.
                Then, the server MUST verify that its own public key certificate is contained in the <a data-lt="dtc-sender">sender</a> field.
                If not, the server MUST send a <code>BogusSenderCert</code> error to the client according to Section <a href="#dtcgenver-generation-errors"></a>.
                <p class="note">
                  This step prevents the client from simply replacing the sender's public key certificate with a bogus certificate, for which it controls the private key, and can thus create a signature (and thus a valid DTC) independent of the sender.
                  While such an attack would not lead to a valid DTC issued by the sender, it would lead to an invaluable DTC, which is not recognized by the sender by simply verifying the DTC using the procedure specified in Section <a href="#dtcgenver-verification"></a>.
                </p>
                If the public key certificate is correct, continue with step 7.
              </li>
              <li>
                The server MUST verify <ul>
                  <li>that the receiver's identity (in <a data-lt="dtc-receiver">receiver</a>) is as expected</li>
                  <li>
                    that the receiver's public key certificate (in <a data-lt="dtc-receiver">receiver</a>) is valid and trusted <p class="note">
                      This step SHOULD include checking whether the public key certificate has been issued for the authority identified by the <a>IRI</a> contained in the <a data-lt="dtc-receiver">receiver</a> field.
                      We further discuss this verification step in Section <a href="#considerations-iricertlink"></a>.
                    </p>
                  </li>
                  <li>that the receiver's signature (in <a data-lt="dtc-receiverSig">receiverSig</a> is valid by verifying the signature according to Section <a href="#dtc-signatures-verification"></a>.
                    The receiver's public key contained in the public key certificate in <a data-lt="dtc-receiver">receiver</a> MUST be used for the verification procedure.</li>
                  If any of these verifications fail, the server MUST send an <code>InvalidReceiverContract</code> error message to the client according to <a href="#dtcgenver-generation-errors"></a>.
                  Otherwise, the server SHOULD accept the DTC and SHOULD forward it to a DTC storage system.
                </ul>
              </li>
            </ol>
          </section>
        </div>
      </section>

      <section id="dtcgenver-generation-abbrev">
        <h4>Abbreviated (2-way) Handshake</h4>

        <p>
          The abbreviated handshake assumes that the <a>receiver</a> has full access to the underlying data of the DTC,
          i.e., that the data transmission is completed.
          Further, it assumes that the <a>receiver</a> has access to the <a>sender</a>'s identity and public certificate, i.e., the contents of the <a data-lt="dtc-sender">sender</a> field according to Section <a href="#dtc-data-structure"></a>.
        </p>

        <p>
          If these two assumptions hold, the <a>receiver</a> is able to compile the DTC except for the <a>sender</a>'s signature.
          In this case, only two messages are necessary to establish a valid DTC.
        </p>

        <p>
          Note that if the <a data-lt="dtc-customContent"><code>senderCustomContent</code></a> is to be used, its content MUST be pre-shared before the receiver initiates the handshake, such that the client has access to it when initially compiling the DTC.
        </p>

        <p>
          The following figure gives an overview of the handshake messages and computations.
          Note that only the differential message contents are listed, as the previously existing DTC content is carried over to the next messages.
          The caption includes a mapping from the message abbreviations used in the figure to the message identifiers defined in Section <a href="#dtcgenver-generation-msgids"></a>.
        </p>

        <div class="tlcontent">
          <p>A shortened 2-way handshake dependent on a completed data transmission is shown below:</p>
          <figure id="fig-dtc-generation-handshake-abbrev" style="text-align: center;">
            <object data="figures/contract-generation-handshake-abbrev.svg" style="width: 80%;" type="image/svg+xml" aria-describedby="fig-dtc-generation-handshake-abbrev">
            </object>
            <p id="fig-contract-generation-handshake-abbrev-alt">
              The transmission-dependent 2-way contract generation handshake </p>
            <figcaption>
              A message diagram of the 2-way contract generation handshake, initiated by the <a>receiver</a> (<span class="fig-agent">R</span>).
              The <a>receiver</a> compiles the complete DTC, and the <a>sender</a> (<span class="fig-agent">S</span>)
              verifies and signs it afterward.
              Message abbreviations: R1'=<code>AbbrevContractRequest</code>, S1'=<code>AbbrevContract</code>.
            </figcaption>
          </figure>

          <p>
            In the following, we define the behavior of client and server implementations in detail.
          </p>

          <section class="notoc">
            <h2>Handshake initiation (Client-side)</h2>

            <p>
              The client is responsible for initiating the DTC generation handshake.
              For this, an appropriate user interface (manual trigger) or interface to the data-sharing system (automatic trigger) SHOULD be implemented.
            </p>

            <ol>
              <li>
                To initiate the DTC generation, the client MUST first compile a partial DTC.
                For this, the following steps MUST be carried out in any order:
                <ul>
                  <li>
                    The client adds the <a data-lt="dtc-receiver">receiver</a> field with its own information, such that the content complies with Section <a href="#dtc-data-structure"></a>.
                  </li>
                  <li>
                    The client adds the <a data-lt="dtc-sender">sender</a> field with the <a>sender</a>'s information,
                    such that the content complies with Section <a href="#dtc-data-structure"></a>.
                    <p class="note">
                      As mentioned above, the content of the <a data-lt="dtc-sender">sender</a> field needs to be pre-shared between <a>sender</a> and <a>receiver</a> for the abbreviated handshake.
                    </p>
                  </li>
                  <li>
                    Based on the set of <a>IRIs</a> of the underlying data transmission, the client compiles the <a data-lt="dtc-facts">facts</a> field in compliance with Section <a href="#dtc-data-structure"></a>.
                    For this, the client looks up or computes the checksums for the <a>facts</a> identified by the <a>IRIs</a> of the data transmission.
                    It then adds each checksum to the <a data-lt="dtc-facts-alg"><code>&lt;alg&gt;</code></a> sub-field of the respective <a data-lt="dtc-facts">facts</a> entry in accordance with Section <a href="#dtc-data-structure"></a>.
                    As specified in Section <a href="#dtc-data-structure"></a>, the checksum is associated with a specific serialization of the <a>fact</a>.
                    The client MUST add the serialization identifier to the <a data-lt="dtc-facts-serialization">serialization</a> sub-field of each entry of <a data-lt="dtc-facts">facts</a> according to Section <a href="#dtc-data-structure"></a>.
                    The <a data-lt="dtc-facts-requestedID">requestedID</a> subfield SHOULD NOT be present for any entry of <a data-lt="dtc-facts">facts</a>.
                    <p class="note">
                      Note that in the abbreviated handshake, the <a>sender</a> cannot update the entries of <a data-lt="dtc-facts-factID">factID</a>, as the <a>receiver</a>'s signature already exists in the first message addressed to the sender.
                      Instead, an <a>IRI</a> negotiation, as discussed in Section <a href="#dtc-data-structure"></a>
                      SHOULD be implemented together with the data transmission, as this has to be completed before the handshake if using the abbreviated handshake version.
                    </p>
                  </li>
                  <li>
                    The client creates a timestamp of its current time and adds it to the <a data-lt="dtc-timestamp">timestamp</a> field according to Section <a href="#dtc-data-structure"></a>.
                  </li>
                  <li>
                    The client assigns a base <a>IRI</a> to the <a data-lt="dtc-baseIRI">baseIRI</a> field according to Section <a href="#dtc-data-structure"></a>, which can be used to uniquely identify the created DTC.
                    This <a>IRI</a> MAY be created by the <a>receiver</a> itself, or negotiated or created by the <a>sender</a> during the transmission of the data subject to the DTC.
                  </li>
                  <li>
                    <i>(Optional)</i>
                    The client adds content to the <a data-lt="dtc-customContent"><code>receiverCustomContent</code></a>
                    and <a data-lt="dtc-customContent"><code>senderCustomContent</code></a> fields according to <a href="#dtc-data-structure"></a>.
                    <p class="note">
                      As mentioned above, the content of the <a data-lt="dtc-customContent"><code>senderCustomContent</code></a> field has to be pre-shared before the abbreviated handshake.
                    </p>
                  </li>
                </ul>
                <p>Continue with step 2.</p>
              </li>
              <li>
                The client MUST create a signature according to Section <a href="#dtc-signatures-creation"></a> for the compiled DTC and the private key associated with the public key included in the public key certificate in the <a data-lt="dtc-receiver">receiver</a> field.
                The client then MUST add it as the <a data-lt="dtc-receiverSig">receiverSig</a> field according to Section <a href="#dtc-data-structure"></a>.
                Continue with step 3.
              </li>
              <li>
                <p>
                  The client then MUST use the partial DTC to build the <code>AbbrevContractRequest</code> message by passing the partial DTC to the message builder defined in Section <a href="#dtcgenver-generation-msgbuilder"></a>, and pass it to the <a>outgoing message interface</a>
                  (see Section <a href="#dtcgenver-generation-protocol"></a>).
                </p>
              </li>
            </ol>

          </section>

          <section class="notoc">
            <h2>Client-side Incoming Message Handling</h2>

            <p>
              Once the client implementation is called by the <a>incoming message handler</a> (see Section <a href="#dtcgenver-generation-protocol"></a>), the following procedure MUST be carried out.
            </p>

            <p>
              Start with step 1.
              If no "continue with step x" phrase is hit, the procedure is finished.
            </p>

            <ol>
              <li>
                The client MUST pass the received message, together with an arbitrarily ordered list of the tuples <code>(id,schema)</code> of all <a>error message identifiers</a> (defined in Section <a href="#dtcgenver-generation-msgids"></a>) and their respective schemas (defined in Section <a href="#dtcgenver-generation-msgschemas"></a>), to the message validator (see Section <a href="#dtcgenver-generation-msgvalidator"></a>).
                If the validation returns <code>None</code>, continue with step 2.
                If the validation returns one of the error message identifiers, the implementation MAY behave arbitrarily (see the discussion and behavior recommendation in Section <a href="#dtcgenver-generation-errors"></a>).
              </li>
              <li>
                The client MUST pass the message, along with the schema for an <code>AbbrevContract</code> message (defined in Section <a href="#dtcgenver-generation-msgschemas"></a>), to the message validator (see Section <a href="#dtcgenver-generation-msgvalidator"></a>).
                If <code>None</code> is returned by the message validator, the client SHOULD send an <code>UnknownMessage</code> error to the server according to Section <a href="#dtcgenver-generation-errors"></a>.
                If the validator returns <code>S1</code>, continue with step 3.
              </li>
              <li>
                The client MUST parse the DTC contained in the <code>contract</code> field of the JSON message.
                Then, the client MUST verify that its own public key certificate is contained in the <a data-lt="dtc-receiver">receiver</a> field.
                If not, the client MUST send a <code>BogusReceiverCert</code> error to the server according to Section <a href="#dtcgenver-generation-errors"></a>.
                <p class="note">
                  This step prevents the server from simply replacing the receiver's public key certificate with a bogus certificate, for which it controls the private key, and can thus create a signature (and thus a valid DTC) independent of the receiver.
                  While such an attack would not lead to a valid DTC issued by the receiver, it would lead to an invaluable DTC, which is not recognized by the receiver by simply verifying the DTC using the procedure specified in Section <a href="#dtcgenver-verification"></a>.
                </p>
                If the public key certificate is correct, continue with step 4.
              </li>
              <li>
                The client MUST verify <ul>
                  <li>that the sender's identity (in <a data-lt="dtc-sender">sender</a>) is as expected</li>
                  <li>
                    that the sender's public key certificate (in <a data-lt="dtc-sender">sender</a>) is valid and trusted <p class="note">
                      This step SHOULD include checking whether the public key certificate has been issued for the authority identified by the <a>IRI</a> contained in the <a data-lt="dtc-sender">sender</a> field.
                      We further discuss this verification step in Section <a href="#considerations-iricertlink"></a>.
                    </p>
                  </li>
                  <li>that the sender's signature (in <a data-lt="dtc-senderSig">senderSig</a> is valid by verifying the signature according to Section <a href="#dtc-signatures-verification"></a>.
                    The sender's public key contained in the public key certificate in <a data-lt="dtc-sender">sender</a> MUST be used for the verification procedure.</li>
                  If any of these verifications fail, the client MUST send a <code>InvalidAbbrevContract</code> error message to the server according to <a href="#dtcgenver-generation-errors"></a>.
                  Otherwise, the client SHOULD accept the DTC and SHOULD forward it to a DTC storage system.
                </ul>
              </li>
            </ol>
          </section>

          <section class="notoc">
            <h2>Server-side Incoming Message Handling</h2>

            <p>
              Once the server implementation is called by the <a>incoming message handler</a> (see Section <a href="#dtcgenver-generation-protocol"></a>), the following procedure MUST be carried out.
            </p>

            <p>
              Start with step 1.
              If no "continue with step x" phrase is hit, the procedure is finished.
            </p>

            <ol>
              <li>
                The server MUST pass the received message, together with an arbitrarily ordered list of the tuples <code>(id,schema)</code> of all <a>error message identifiers</a> (defined in Section <a href="#dtcgenver-generation-msgids"></a>) and their respective schemas (defined in Section <a href="#dtcgenver-generation-msgschemas"></a>), to the message validator (see Section <a href="#dtcgenver-generation-msgvalidator"></a>).
                If the validation returns <code>None</code>, continue with step 2.
                If the validation returns one of the error message identifiers, the implementation MAY behave arbitrarily (see the discussion and behavior recommendation in Section <a href="#dtcgenver-generation-errors"></a>).
              </li>
              <li>
                The server MUST pass the message, together with the <code>AbbrevContractRequest</code> schema (see Section <a href="#dtcgenver-generation-msgschemas"></a>) to the message validator (see <a href="#dtcgenver-generation-msgvalidator"></a>).
                If the validator returns <code>None</code>, the server MUST send an <code>UnknownMessage</code> error to the client according to Section <a href="#dtcgenver-generation-errors"></a>.
                If the validator returns <code>AbbrevContractRequest</code>, continue with step 3.
              </li>
              <li>
                <p>
                  The server MUST extract and parse the partial DTC contained in the <code>content</code> attribute of the JSON message, and verify </p>
                <ul>
                  <li>that the receiver's identity (in <a data-lt="dtc-receiver">receiver</a>) is as expected</li>
                  <li>
                    that the receiver's public key certificate (in <a data-lt="dtc-receiver">receiver</a>) is valid and trusted <p class="note">
                      This step SHOULD include checking whether the public key certificate is issues for the authority identified by the <a>IRI</a> contained in the <a data-lt="dtc-receiver">receiver</a> field.
                      We further discuss this verification step in Section <a href="#considerations-iricertlink"></a>.
                    </p>
                  </li>
                  <li>that the receiver's signature (in <a data-lt="dtc-receiverSig">receiverSig</a>) is valid by verifying the signature according to Section <a href="#dtc-signatures-verification"></a>.
                    The receiver's public key contained in the public key certificate in <a data-lt="dtc-receiver">receiver</a> MUST be used for the verification procedure.</li>
                  <li>that the <a>fact</a> checksums contained in <a data-lt="dtc-facts">facts</a> are valid.
                    This verification step can be done by re-computing or looking up the fact checksums given the serialization identified by the <a data-lt="dtc-facts-serialization">serialization</a> field.
                    <p class="note">
                      In contrast to the 3-way handshake (see Section <a href="#dtcgenver-generation-complete"></a>),
                      this step is not optional, as the 2-way handshake requires a previously completed data transmission.
                      Thus, making this step mandatory does not constrain the application of the procedure.
                    </p>
                  </li>
                </ul>
                If any of these verifications fail, the server MUST send an <code>InvalidAbbrevContractRequest</code>
                error message to the client according to Section <a href="#dtcgenver-generation-errors"></a>.
                If all of the verifications succeeded, continue with step 5.
              </li>
              <li>
                The server MUST verify that its own identity and public key certificate are correctly included in the <a data-lt="dtc-sender">sender</a> field.
                <p class="note">
                  This information has to be pre-shared between sender and receiver for the abbreviated handshake.
                  If this information is not correct, the signature in step 6 cannot be created with the matching private key.
                </p>
                If not, the server MUST send a <code>BogusSenderCert</code> error message to the client according to Section <a href="#dtcgenver-generation-errors"></a>.
                If the information is correct, continue with step 6.
              </li>
              <li>
                The server MUST create a signature according to Section <a href="#dtc-signatures-creation"></a> using the partial DTC from the <code>AbbrevContractRequest</code> message and the private key associated with the public key included in the public key certificate in the <a data-lt="dtc-sender">sender</a> field,
                and add it as the <a data-lt="dtc-senderSig">senderSig</a> field according to Section <a href="#dtc-data-structure"></a>.
                The server SHOULD accept the complete DTC and SHOULD forward it so a DTC storage system.
                Finally, the server MUST build the <code>AbbrevContract</code> message by passing the now-complete DTC to the message builder (see Section <a href="#dtcgenver-generation-msgbuilder"></a>), and use the <a>outgoing message interface</a> (see Section <a href="#dtcgenver-generation-protocol"></a>) to send it to the client.
              </li>
            </ol>
          </section>

        </div>
      </section>

      <section id="dtcgenver-generation-msgids">
        <h2>Message Identifiers</h2>

        <p>
          The defined <dfn>message identifiers</dfn> are partitioned into <a>non-error message identifiers</a> and <a>error message identifiers</a>.
        </p>

        <p>
          We do not further specify the implementation of the message identifiers.
          They could, for example, be implemented using constant string values, or with an enum-like structure.
        </p>

        <p>We define the following <dfn>non-error message identifiers</dfn>:</p>
        <ul>
          <li><code>ContractRequest</code>: Identifies the first message in the complete handshake defined in Section <a href="#dtcgenver-generation-complete"></a>.</li>
          <li><code>SenderContract</code>: Identifies the second message in the complete handshake defined in Section <a href="#dtcgenver-generation-complete"></a>.</li>
          <li><code>ReceiverContract</code>: Identifies the third message in the complete handshake defined in Section <a href="#dtcgenver-generation-complete"></a>.
          </li>
          <li><code>AbbrevContractRequest</code>: Identifies the first message of the abbreviated handshake defined in Section <a href="#dtcgenver-generation-abbrev"></a>.</li>
          <li><code>AbbrevContract</code>: Identifies the second message of the abbreviated handshake defined in Section <a href="#dtcgenver-generation-abbrev"></a>.
          </li>
        </ul>

        <p>We define the following <dfn>error message identifiers</dfn>:</p>
        <ul>
          <li>
            <code>UnknownMessage</code>:
            Indicates that the message could not be validated against any message schema.
          </li>
          <li>
            <code>UnexpectedSenderContract</code>:
            Indicates that an <code>S1</code> message was received by the client without expecting it (see Section <a href="#dtcgenver-generation-complete"></a>).
          </li>
          <li>
            <code>InvalidSenderContract</code>:
            Indicates that the verification of an <code>S1</code> message failed (see Section <a href="#dtcgenver-generation-complete"></a>).
          </li>
          <li>
            <code>BogusSenderCert</code>:
            Indicates that the public key certificate contained in the <a data-lt="dtc-sender">sender</a> field of an <code>R2</code> message did not equal the <a>sender</a>'s actual certificate (see Section <a href="#dtcgenver-generation-complete"></a>).
          </li>
          <li>
            <code>InvalidReceiverContract</code>:
            Indicates that the verification of the previously transmitted <code>ReceiverContract</code> message on the server side failed.
          </li>
          <li>
            <code>BogusReceiverCert</code>:
            Indicates that the <a>receiver</a>'s certificate, as included in the <a data-lt="dtc-receiver">receiver</a>
            field of the partial DTC within the previously transmitted <code>SenderContract</code> message, was not the correct certificate of the handshake client.
          </li>
          <li>
            <code>InvalidAbbrevContract</code>:
            Indicates that the client-side verification of the previously transmitted <code>AbbrevContract</code>
            message failed.
          </li>
          <li>
            <code>InvalidAbbrevContractRequest</code>:
            Indicates that the server-side verification of the previously transmitted <code>AbbrevContractRequest</code>
            message failed.
          </li>
        </ul>
      </section>

      <section id="dtcgenver-generation-msgbuilder">
        <h3>Message Builder</h3>

        <p>
          The message builder is used to build JSON messages to be transmitted according to Section <a href="#dtcgenver-generation-protocol"></a>.
          Its behavior is the same for client and server implementations, and it provides an interface for the implementation of both server and client behavior, as specified in Sections <a href="#dtcgenver-generation-complete"></a> and <a href="#dtcgenver-generation-abbrev"></a>.
        </p>

        <p>
          If an implementation implements the client or server part of the generation handshake, it MUST also implement the message builder.
        </p>

        <p>The message builder MUST implement the following functionality.</p>

        <ul>
          <li>
            <i>Input:</i>
            A <a>non-error message identifier</a> (see Section <a href="#dtcgenver-generation-msgids"></a>) and a (partial) DTC <p class="note">Details about building error messages can be found in Section <a href="#dtcgenver-generation-errors"></a>.</p>
          </li>
          <li>
            <i>Behavior:</i>
            The message builder MUST carry out the following steps:
            <ol>
              <li>Create an empty JSON object (<code>{}</code>), referred to as <code>res</code>.</li>
              <li>Assign the <a>message identifier</a> to <code>res</code> as the string content of the <code>messageType</code> attribute.
              </li>
              <li>Serialize the (partial) DTC as a JSON object according to Section <a href="#dtc-representations-json"></a>, and assign it to <code>res</code> as the <code>contract</code>
                attribute.</li>
              <li>Return <code>res</code> to the caller.</li>
            </ol>
          </li>
        </ul>

        <p>The following is an informative example of an <code>S1</code> message (see Section <a href="#dtcgenver-generation-complete"></a>) as generated by the message builder.</p>
        <pre class="example" data-include="examples/example-message-s1.json" title="Example handshake message (SenderContract)"></pre>
      </section>

      <section id="dtcgenver-generation-msgschemas">
        <h3>Message Schemas</h3>

        <p>
          We define one message schema per <a>message identifier</a>.
        </p>

        <p>For this, we build upon the same specification of <a href="https://json-schema.org/draft/2020-12/json-schema-core.html">JSON Schema</a>
          [[JSON-SCHEMA]][[JSON-SCHEMA-VALIDATION]] as in Section <a href="#dtc-representations-json"></a>.</p>

        <p>
          The message schemas can be obtained through the following links:
        </p>

        <ul>
          <li>
            Abstract (generic) schemas:
            <ul>
              <li>Generic message: <a href="schemas/message/message.schema.json" class="external" target="_blank">Schema</a></li>
              <li>Generic error message: <a href="schemas/message/error/error_message.schema.json" class="external" target="_blank">Schema</a></li>
              <li>Partial DTC: <a href="schemas/partial_dtc.schema.json" class="external" target="_blank">Schema</a>
              </li>
            </ul>
          </li>
          <li>
            Non-error message schemas:
            <ul>
              <li><code>ContractRequest</code>: <a href="schemas/message/contract_request.schema.json" class="external" target="_blank">Schema</a></li>
              <li><code>SenderContract</code>: <a href="schemas/message/sender_contract.schema.json" class="external" target="_blank">Schema</a></li>
              <li><code>ReceiverContract</code>: <a href="schemas/message/receiver_contract.schema.json" class="external" target="_blank">Schema</a></li>
              <li><code>AbbrevContractRequest</code>: <a href="schemas/message/abbrev_contract_request.schema.json" class="external" target="_blank">Schema</a></li>
              <li><code>AbbrevContract</code>: <a href="schemas/message/abbrev_contract.schema.json" class="external" target="_blank">Schema</a></li>
            </ul>
          </li>
          <li>
            Error message schemas:
            <ul>
              <li><code>UnknownMessage</code>: <a href="schemas/message/error/unknown_message.schema.json" class="external" target="_blank">Schema</a></li>
              <li><code>UnexpectedSenderContract</code>: <a href="schemas/message/error/unexpected_sender_contract.schema.json" class="external" target="_blank">Schema</a></li>
              <li><code>InvalidSenderContract</code>: <a href="schemas/message/error/invalid_sender_contract.schema.json" class="external" target="_blank">Schema</a></li>
              <li><code>BogusSenderCert</code>: <a href="schemas/message/error/bogus_sender_cert.schema.json" class="external" target="_blank">Schema</a></li>
              <li><code>InvalidReceiverContract</code>: <a href="schemas/message/error/invalid_receiver_contract.schema.json" class="external" target="_blank">Schema</a></li>
              <li><code>BogusReceiverCert</code>: <a href="schemas/message/error/bogus_receiver_cert.schema.json" class="external" target="_blank">Schema</a></li>
              <li><code>InvalidAbbrevContract</code>: <a href="schemas/message/error/invalid_abbrev_contract.schema.json" class="external" target="_blank">Schema</a></li>
              <li><code>InvalidAbbrevContractRequest</code>: <a href="schemas/message/error/invalid_abbrev_contract_request.schema.json" class="external" target="_blank">Schema</a></li>
            </ul>
          </li>
        </ul>


      </section>

      <section id="dtcgenver-generation-msgvalidator">
        <h3>Message Validator</h3>

        <p>
          The message validator is used to validate a JSON message against an ordered list of schemas.
          It provides an interface to the client and server implementations specified in Sections <a href="#dtcgenver-generation-complete"></a> and <a href="#dtcgenver-generation-abbrev"></a>.
        </p>

        <p>
          Any implementation implementing the client or server part of the generation handshake MUST also implement the message validator.
        </p>

        <p>The behavior of the message validator MUST be implemented as follows:</p>
        <ul>
          <li>
            <i>Input:</i>
            A JSON object (referred to as <code>msg</code>) and a list of tuples <code>(id_0,schema_0),...,(id_n-1,schema_n-1)</code>, where for <code>i=0,...,n-1</code>, <code>id_i</code>
            is a <a>message identifier</a>, and <code>schema_i</code> is the according JSON schema according to Section <a href="#dtcgenver-generation-msgschemas"></a>.
          </li>
          <li>
            <i>Behavior:</i>
            The validator tries to validate <code>msg</code> against the JSON Schemas, starting with <code>schema_0</code>, applying a first-match policy.
            That is, for the first tuple <code>(id_i,schema_i)</code>, such that <code>msg</code> matches <code>schema_i</code>, the message validator terminates and returns <code>id_i</code> to the caller.
            If none of the schemas match <code>msg</code>, the validator returns <code>None</code> (which MAY be represented as a string or as a language-internal representation of a null value).
          </li>
        </ul>
      </section>

      <section id="dtcgenver-generation-errors">
        <h3>Error Message Builder & Error Handling</h3>

        <p>
          We define a special message builder for <a>error message identifiers</a>, which provides an interface to the client and server implementations in Sections <a href="#dtcgenver-generation-complete"></a> and <a href="#dtcgenver-generation-abbrev"></a>.
        </p>

        <p>
          Any implementation implementing the client or server part of the generation handshake MUST also implement the error message builder.
        </p>

        <p>
          The error message builder MUST be implemented with the following functionality:
        </p>
        <ul>
          <li>
            <i>Input:</i>
            An <a>error message identifier</a>
          </li>
          <li>
            <i>Behavior:</i>
            The error message builder MUST carry out the following steps:
            <ol>
              <li>Create an empty JSON object (<code>{}</code>) referred to as <code>res</code>.</li>
              <li>Assign the <a>error message identifier</a> as a string to the <code>messageType</code> attribute of <code>res</code>.
              </li>
              <li>
                Assign an implementation-dependent error message as a string to the <code>errorMessage</code> attribute of <code>res</code>.
                <p class="note">
                  This field can be used to carry further meta-information about the error occurrence, but is not further specified.
                </p>
              </li>
              <li>Return <code>res</code> to the caller.</li>
            </ol>
          </li>
        </ul>

        <p>The following is an informative example of an error message with the <code>UnknownMessage</code> <a>message identifier</a> as generated by the error message builder.</p>
        <pre class="example" data-include="examples/example-message-error.json" title="Example error message (UnknownMessage)"></pre>

        <p>
          Note that we do not specify how error messages are handled.
          However, we recommend that error messages SHOULD NOT simply be ignored, as this behavior MAY lead to invalid (and thus invaluable) DTCs.
          An implementation SHOULD instead decide to either repeat the handshake step which caused the error, or abort the generation handshake, such that a new handshake can be initiated.
        </p>

      </section>

      <section id="dtcgenver-generation-protocol">
        <h3>Protocol Stack</h3>

        <div class="tlcontent">
          <p>
            The JSON messages are either transmitted directly on top of <a href="https://datatracker.ietf.org/doc/html/rfc793">TCP</a> [[RFC793]], via <a href="https://datatracker.ietf.org/doc/html/rfc6961">TLS</a> directly on top of TCP, or wrapped into <a href="https://httpwg.org/specs/rfc7230.html">HTTP</a> [[HTTP11]] requests, optionally over TLS (<a href="https://datatracker.ietf.org/doc/html/rfc2818">HTTPS</a>) [[HTTP-TLS]].
          </p>

          <p>
            In order for the lower protocol stack to be transparent for the client and server implementation, we define an additional abstraction layer.
            This abstraction layer MUST implement two components:
          </p>
          <ul>
            <li>An <dfn>outgoing message interface</dfn>, which can be called using JSON objects to send messages.</li>
            <li>An <dfn>incoming message handler</dfn>, which forwards valid JSON messages to the client or server implementation.</li>
          </ul>
          <p>
            Depending on the protocol stack, these components are implemented differently, as we specify in the following.
          </p>
          <p>
            If only TCP is used (no TLS or HTTP on top), the server MUST provide an open port that can be contacted by the client.
            Upon contract handshake initiation, the client MUST open a connection to the server, such that both the client and the server have an open bi-directional TCP socket.
            The two abstraction components MUST be implemented as follows for client and server:
          </p>
          <ul>
            <li>
              <a>Outgoing message interface</a>: Whenever called with a valid JSON object, the implementation MUST serialize the JSON as a string in <a href="https://datatracker.ietf.org/doc/html/rfc3629">UTF-8</a>
              encoding [[RFC3629]] and send it through the TCP socket with a trailing newline character.
            </li>
            <li>
              <a>Incoming message handler</a>:
              Whenever the incoming data can be aggregated to a valid JSON object, it MUST be parsed as a JSON object,
              and the associated client or server implementation MUST be called with said JSON object.
            </li>
          </ul>
          <p>
            If TLS is used on top of TCP without HTTP, the server MUST provide an open TCP port that can be contacted by the client, but only accepts TLS traffic.
            Upon contract handshake initiation, the client MUST open a connection to the server and carry out a TLS handshake, such that a TLS-protected tunnel is established.
            Then, the abstraction components (i.e., the <a>outgoing message interface</a> and the <a>incoming message handler</a>) MUST be implemented as in the no-TLS case, but using the TLS tunnel instead.
          </p>
          <p>
            If HTTP or HTTPS is used, the server MUST provide an HTTP(S) server to which the client can connect.
            Upon contract handshake initiation, the client MUST open a TCP connection (without TLS) or create a TLS tunnel through a TLS handshake (with TLS), through which HTTP traffic can be sent.
            For the abstraction components, we differentiate between client and sender.
          </p>
          <p>The client-side abstraction components for HTTP(S) MUST be implemented as follows:</p>
          <ul>
            <li>
              <a>Outgoing message interface</a>:
              Whenever called with a valid JSON object, the implementation MUST create and send an HTTP POST request through the established tunnel, containing the serialized JSON object as its body, and MUST set the <code>Content-Type</code> header to <code>application/json</code>.
              It MUST then install the <a>incoming message handler</a>, such that it gets called with the response to the request.
            </li>
            <li>
              <a>Incoming message handler</a>:
              Is called with the response of a previously executed POST request.
              If the response <code>Content-Type</code> header does not indicate the <code>application/json</code> type,
              the implementation SHOULD initiate a retransmission of the previous message by either sending an <code>UnknownMessage</code> error message (see Sections <a href="#dtcgenver-generation-msgids"></a> and <a href="#dtcgenver-generation-errors"></a>), or by retransmitting the previous message, using the <a>outgoing message interface</a>.
              <p class="note">
                Because the client is not simply able to provide feedback in the form of an HTTP status code, as it only performs requests, we leave error handling to the implementation.
                We refer to the general discussion of ReShare's approach on error handling in Section <a href="#dtcgenver-generation-errors"></a>.
              </p>
            </li>
          </ul>
          <p>The server-side abstraction components for HTTP(S) MUST be implemented as follows:</p>
          <ul>
            <li>
              <a>Outgoing message interface</a>:
              MUST be called with the context of a previously received incoming HTTP POST request.
              The implementation MUST create and send a response to the request in the context with which the outgoing message interface was called.
              The body of the response MUST be set to the JSON object, with which the outgoing message interface was called.
              The status code of a message with a <a>non-error message identifier</a> (see Section <a href="#dtcgenver-generation-msgids"></a>) MUST be set to <code>200</code>.
              The status code of a message with an <a>error message identifier</a> (see Section <a href="#dtcgenver-generation-msgids"></a>) SHOULD be set to one of the acceptable status codes from the table below, depending on the message identifier.
              The <code>Content-Type</code> header MUST be set to <code>application/json</code>.
              <p class="note">
                A <code>200</code> status code is considered acceptable for every defined error message, as these higher-layer errors are already uniquely identified through their respective message schemas.
                Thus, using a <code>200</code> status code does not hinder an implementation's functionality, but we consider the usage of proper error status codes good practice.
              </p>
            </li>
            <li>
              <a>Incoming message handler</a>:
              MUST be called whenever an HTTP request is received from the client.
              If the <code>Content-Type</code> header of the request does not indicate the <code>application/json</code>
              type, the incoming message handler MUST respond with an empty response with a <code>406</code> status code, without calling the server-side implementation of the handshake.
              Else, the body of the request is parsed as a JSON object, and the server-side implementation of the handshake (defined in Sections <a href="#dtcgenver-generation-complete"></a> and <a href="#dtcgenver-generation-abbrev"></a>) is called with the parsed JSON object.
              Additionally, the incoming message handler SHOULD store the context of the request, such that it can be passed to the <a>outgoing message interface</a> once it is called by the server implementation.
            </li>
          </ul>

          <p>
            We define the following acceptable status codes for error messages based on the <a>error message identifiers</a> (see Section <a href="#dtcgenver-generation-msgids"></a>):
          </p>

          <p class="note">
            We only define status codes for error messages which can be sent by the server during the handshake, as a client only sends HTTP requests, which do not carry a status code.
          </p>

          <table class="customtable">
            <thead>
              <tr>
                <th><a>Message identifier</a></th>
                <th>Recommended HTTP Status Codes</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>UnknownMessage</code></td>
                <td><code>200</code>, <code>400</code></td>
              </tr>
              <tr>
                <td><code>BogusSenderCert</code></td>
                <td><code>200</code>, <code>422</code></td>
              </tr>
              <tr>
                <td><code>InvalidReceiverContract</code></td>
                <td><code>200</code>, <code>422</code></td>
              </tr>
              <tr>
                <td><code>InvalidAbbrevContractRequest</code></td>
                <td><code>200</code>, <code>422</code></td>
              </tr>
            </tbody>
          </table>

        </div>
      </section>
    </section>

    <section id="dtcgenver-verification">
      <h3>DTC Verification</h3>
      <div class="tlcontent">
        <p>
          DTC verification can be executed fully locally, as the DTC itself contains all information necessary for its verification.
          This self-containing property of DTCs allows for efficient and unambiguous verification without the need to directly communicate with the involved parties.
        </p>
        <p>
          To verify a DTC and the resources for which it contains checksums, access to the following information is required:
        </p>
        <ul>
          <li>The DTC itself</li>
          <li>The resource(s) to be verified</li>
          <li>A list of trusted root CAs (and their public keys)</li>
        </ul>
        <p>
          The verification steps immediately emerge from the design of the trust chain of DTCs.
          In order to verify a syntactically valid DTC, one MUST execute the following verification steps in any order:
        </p>
        <ul>
          <li>
            Verify the public key certificates by verifying the certificate chains in <a data-lt="dtc-sender">sender</a>
            and <a data-lt="dtc-receiver">receiver</a> using a pre-installed trusted root CA's public key as the trust anchor.
            <p class="note">
              This step SHOULD include checking whether the public key certificates are issued for the respective authorities identified by the <a>IRIs</a> contained in the <a data-lt="dtc-sender">sender</a> and <a data-lt="dtc-receiver">receiver</a> fields.
              We further discuss this verification step in Section <a href="#considerations-iricertlink"></a>.
            </p>
          </li>
          <li>
            Verify the DTC signatures in <a data-lt="dtc-senderSig">senderSig</a> and <a data-lt="dtc-receiverSig">receiverSig</a> using the public keys contained in the certificates in the <a data-lt="dtc-sender">sender</a> and <a data-lt="dtc-receiver">receiver</a> fields and the signature verification process specified in Section <a href="#dtc-signatures-verification"></a>.
          </li>
          <li>
            Verify the fact checksums using the original data.
            For this, the facts need to be serialized according to the serialization format identified in the <a data-lt="dtc-facts-serialization">serialization</a> field.
            Subsequently, the checksums need to be re-computed given the serialized facts, and compared to the checksum included in the DTC.
            <p class="note">
              We do not further specify this verification step, as the process of serializing facts of different types is deemed out-of-scope for this document.
            </p>
          </li>
        </ul>
        <p>
          If any of the verification steps fail, the verification mechanism MUST terminate with a negative result.
        </p>
        <p>
          Depending on the use case, it MAY be desirable to extend these verification steps, e.g., by verifying that the owner of the certificates in the <a data-lt="dtc-receiver">receiver</a> and <a data-lt="dtc-sender">sender</a> fields are as expected.
          While such extensions are not part of this verification mechanism, we advise implementors to carefully review that no unverified assumptions are made about the contents of a DTC.
        </p>
      </div>
    </section>
    <p>
      ReShare with its specification of DTCs, the ontology, and the DTC creation and verification process, enables users to achieve data trustworthiness and reliability in a scalable manner.
      In this context, the central aspect not covered before by Web technology, but essential in the context of data-driven or industrial data sharing settings is the accountable involvement of both parties in the data transmission process, which is implemented using bilateral signatures in ReShare.
    </p>
  </section>
  <section id="considerations" class="informative appendix">
    <h2>Considerations</h2>

    In the following section, we briefly elaborate on some of the design decisions and considerations w.r.t. ReShare.

    <section id="considerations-otherw3ctechs" class="informative">
      <h2>Relation to Other W3C Documents</h2>

      <p>
        In recent years, both W3C itself and W3C Community Groups have been quite active in the field of expressing cryptographically-backed claims or statements about data.
        To the best of our knowledge, the following three documents are especially noteworthy:
      </p>
      <ul>
        <li>Verifiable Credentials [[VC-DATA-MODEL]],</li>
        <li>Data Integrity [[DATA-INTEGRITY]], and</li>
        <li>Decentralized Identifiers [[DID-CORE]].</li>
      </ul>
      <p>
        ReShare was developed largely in parallel to these developments throughout years 2020 until early 2021, and the major parts of this document were created mostly from April to the end of 2021.
        ReShare was designed with backward-compatability with the existing Web infrastructure in mind and as such makes use of established standards at the time of design as a largely self-contained solution.
        That being said, future work, e.g., towards standardization, may potentially also make use of these related efforts.
        A potential role of Decentralized Identifiers in ReShare is discussed in Section <a href="#considerations-iricertlink"></a>.
        In the following, we focus on Verifiable Credentials and the Data Integrity specification.
      </p>

      <section class="notoc">
        <h2>
          Verifiable Credentials
        </h2>

        <p>
          Verifiable Credentials (VC) [[VC-DATA-MODEL]] provide a cryptographically-secure and machine-readable approach to expressing credentials.
          An overview of conceivable use cases can be found in [[VC-USE-CASES]], and include a variety of claims in the areas of education, finance, healthcare and more.
        </p>

        <p>
          The data model of a VC is defined independently from its representation.
          However, the specification defines both a JSON, and a JSON-LD representation, thus taking a very similar approach to ReShare.
        </p>

        <p>
          As VCs represent very general means of expressing, presenting, and proving a set of claims in the form of credentials, it is conceivable that VCs could be used as a framework for an implementation of DTCs, together with a DTC generation mechanism similar to the one we currently specify.
        </p>

        <p>
          However, the following two considerations have lead us to the decision of refraining from the use of VCs in ReShare as of now:
        </p>
        <ol>
          <li>
            <p>
              While a credential is defined as essentially consisting of metadata, one ore more claims, and one or more proofs, which is applicable to the model of a DTC, the use cases in [[VC-USE-CASES]] are very much centered around use cases of a single individual in everyday life.
            </p>
            <p>
              This makes us wonder whether applicability in typical use-cases of inter-organizational data sharing of ReShare is given, as such scenarios might not have been considered in the design of the VC specification.
            </p>
          </li>
          <li>
            <p>
              Probably the most essential design choice defining the paradigm of DTCs lies in the idea of bilateral on-demand signatures, as we describe in-detail in Section <a href="#dtc-signature-paradigm"></a>.
            </p>
            <p>
              In the VC specification, while multiple proofs within a single VC are supported, a VC always has one issuer by design (see <a href="https://www.w3.org/TR/vc-data-model/#issuer">4.5 Issuer</a>), which is incompatible with the paradigm of a DTC having two equally-involved parties, the <a>sender</a> and the <a>receiver</a>, whose signatures are both required for a DTC to be considered valid.
            </p>
          </li>
        </ol>
        <p>
          Of course, depending on future developments, the suitability of VC as a framework for DTCs should be re-assessed if a new version of ReShare is to be designed in future.
        </p>

        <p>
          For example, as we discuss below, signature sets, as used in contracts, are included in the Data Integrity [[DATA-INTEGRITY]] specification, and could find their way into a future version of the VC specification, possibly expanding the set of use cases to those of DTCs.
        </p>

      </section>

      <section class="notoc">
        <h2>Data Integrity</h2>

        <p>
          The Data Integrity specification [[DATA-INTEGRITY]] strives to provide data models and representations of cryptographic proofs, such as signatures and integrity checksums, within the context of Linked Data.
        </p>

        <p>
          Such mechanisms clearly find a promising use case in DTCs, as DTCs include integrity checksums of the data subject to the underlying data transmission (see <a data-lt="dtc-facts">facts</a>), as well as digital signatures of both DTC parties (see <a data-lt="dtc-sender">sender</a> and <a data-lt="dtc-receiver">receiver</a>).
          Even proof sets are already included in the Data Integrity specification (see <a href="https://w3c-ccg.github.io/data-integrity-spec/#proof-sets">3.1 Proof Sets</a>), for which we deem DTCs a very interesting use case.
        </p>

        <p>
          Naturally, ReShare would greatly profit from employing a standardized mechanism of including and structuring these cryptographic proofs in DTCs.
          Therefore, we consider the Data Integrity specification as a promising mechanism to be used in a future version of ReShare.
        </p>

        <p>
          As of now, ReShare uses a custom implementation of embedding signatures and checksums in DTCs, which has to be attributed to the temporal overlap of ReShare and the Data Integrity specification, as the Data Integrity specification is in a relatively early stage of standardization.
        </p>
      </section>
    </section>

    <section id="considerations-iricertlink" class="informative">
      <h2>Identity Management</h2>
      <!--Linking Authority IRIs to Public Key Certificates-->

      <p>
        Tackling the challenge of integrating a consistent and well-designed identity management approach, which also seamlessly interoperates within the ecosystem of common application contexts, clearly is a non-trivial task.
        We elaborate on our considerations w.r.t. an identity management system within ReShare in the following.
      </p>

      <section class="notoc">
        <h2>Current Approach</h2>

        <p>
          ReShare employs X.509 certificates for identity management.
          Parties of a contract are reliably linked to their signatures through their public key, which is contained in the DTC itself.
          Through this approach, we achieve a robust link between the party identified through an X.509 certificate to the signature that party creates.
        </p>

        <p>
          However, the linking of an X.509 certificate to the party itself (e.g., a physical person or company) is also a major task in defining an identity management system.
          Here, we give recommendations on what such an approach should fulfill, but in general consider this task out of scope for ReShare.
        </p>


        <p>
          The information about the two signing parties of a DTC include a public key certificate and an <a>IRI</a> - separated from the certificate - per party.
          These <a>IRI</a> and public key certificate of a party are included in the <a data-lt="dtc-sender">sender</a> and <a data-lt="dtc-receiver">receiver</a> fields of a DTC,
          as described in Section <a href="#dtc-data-structure"></a>.
        </p>

        <p>
          However, the <a>IRI</a> of a party should additionally be included in the subject part of a party's public key certificate.
          Thereby, the party identified through the <a>IRI</a> can be held accountable for the uses of the private key matching the public key provided in the X.509 certificate, as long as the certificate validity is trusted.
        </p>

        <p>
          For this link of <a>IRI</a> to X.509 certificate to be trustworthy, self-signed X.509 certificates are only conceivable for testing purposes.
          In productive use, for the DTC to be valuable, certificates should always be valid within a certificate chain starting at a root certificate, which is commonly trusted by all conceivable verifiers of the DTC to be created.
        </p>

        <p>
          As specified in Section <a href="#dtc-data-structure"></a>, we leave our system open to extensions w.r.t. other certificate technologies than X.509.
          Therefore, we also decided not to further specify a mechanism of mapping <a>IRIs</a> to parties such as phyisical persons or organizations, but consider it out of scope.
        </p>

        <p>
          However, in the following, we discuss how new technologies and standardization approaches of W3C could be used in future to extend or improve identity management in ReShare.
        </p>
      </section>

      <section class="notoc">
        <h2>Possible Future Adaptions</h2>

        <p>
          We opted to use X.509 as our Public Key Infrastructure (PKI), as it is a commonly trusted system, and therefore does not hinder acceptability of ReShare.
        </p>

        <p>
          However, X.509 is quite inflexible with the employed trust infrastructure, as it enforces a hierarchical trust structure by design.
          Furthermore, while it is a common use case of X.509 to verifiably link certificates to domain names, to the best of our knowledge, a mechanism to verifiably link certificates to parties such as persons or organizations can hardly be found.
        </p>

        <p>
          For these reasons, deviating from pure use of X.509 certificates in ReShare may prove to be best in future.
          One technology is especially noteworthy with these regards, which is the Decentralized Identifiers specification [[DID-CORE]].
        </p>

        <p>
          A Decentralized Identifier (DID) allows to identify an arbitrary entity, such as an individual or organization.
          Because DIDs themselves are <a href="https://www.w3.org/TR/did-core/#dfn-uri">URIs</a> (Uniform Resource Identifiers), which in turn is a subset of <a>IRIs</a>, DIDs could be used within ReShare with ease.
        </p>

        <p>
          However, the DIDs themselves only define a mechanism to access the DID document related to the DID, which contains the statements the DID makes, including the link to a physical identity, or the public key material.
          For the accountability and verifiability guarantees we deem crucial in ReShare, such information should be self-contained within a DTC itself.
          Now, while it is conceivable to directly include DID documents in a DTC, this conflicts with an essential design choice of [[DID-CORE]], that is, that the DID controller is in charge of altering, or more generally, controlling the DID document.
          When this DID document is included within the DTC, this makes the DID document immutable without the DTC losing its validity, and thus takes away the control from the DID controller.
          It is hard to say whether this deviation from the design of [[DID-CORE]] would be reasonable.
        </p>

        <p>
          If one decides to employ DIDs in DTCs, and directly includes the attached DID documents in some representations, the DID document could completely replace the public key certificate of a party within ReShare.
          A public key can optionally be directly included within the DID document (see <a href="https://www.w3.org/TR/did-core/#verification-material">5.2.1 Verification Material</a>), making an external public key certificate unnecessary, as long as the trustworthiness of this public key can be guaranteed.
        </p>
        <p>
          In our current approach, we have established verifiability independent of certificate availability by including the public key certificates directly within a DTC.
          For the use of DIDs to provide the same verifiability guarantees, the following points would have to be fulfilled:
        </p>
        <ul>
          <li>The DID document has to be included in the DTC itself (see above),</li>
          <li>
            the DID document has to contain a public key (as a JSON Web Key, JWK [[RFC7517]]), and
          </li>
          <li>
            the JWK has to contain the X.509 certificate chain (see the <a href="https://datatracker.ietf.org/doc/html/rfc7517#section-4.7"><code>x5c</code> property</a>).
          </li>
        </ul>
        <p>
          Note that both the use of <code>publicKeyJwk</code> in [[DID-CORE]] and the use of <code>x5c</code> in [[RFC7517]] are optional, and thus would have to be enforced in a future version of ReShare.
        </p>

        <p>
          Furthermore, as the use of JWKs is currently the only specified stable mechanism for including public keys in DID documents (see <a href="https://www.w3.org/TR/did-core/#verification-material">5.2.1 Verification Material</a>), and JWKs rely on X.509 certificates, we still find ourselves with the disadvantages of using an X.509 PKI when using DIDs as of now.
        </p>

        <p>
          Because of the stated disadvantages of X.509 certificates, we see the need for a novel mechanism to prove possession of a public key, which clearly relates said key to an entity.
          Such a mechanism should integrate well within the modern ecosystem of Linked Data, while building upon a secure and trusted PKI with well-defined methods to register or create your own certificate, which is linked to you as a person, organization, or different entity.
        </p>
      </section>

    </section>

    <section id="considerations-2or3wayhs" class="informative">
      <h2>DTC Generation: Two Handshake Versions</h2>
      <p>
        We have introduced the shortened 2-way handshake as a way to reduce the communication overhead in an application scenario with high communication latencies.
        However, this shortened version requires that the transmission of the data which is signed in a given DTC is completed before DTC generation.
        With the complete 3-way handshake, the DTC generation is completely independent of the underlying data transmission, except that the <a>receiver</a> has to know which resources are transmitted.
      </p>
      <p>
        The sequentiality arising from a dependency on the data transmission has practical disadvantages in many cases, such as an increased management and implementation overhead by more closely integrating the data transmission process into the DTC generation mechanism.
        Given the context system, configuration or implementation changes in the data transmission backend might be necessary to implement the necessary pre-sharing to allow for a short handshake.
      </p>

      <p>
        Therefore, we consider the complete 3-way handshake the default handshake, but still specify the shortened 2-way handshake for special high-latency environments.
        Without a strong argument against it, we advise to use the 3-way handshake.
      </p>
    </section>

  </section>

  <!-- Only appendix from here -->
  <section id="acknowledgements" class="appendix">
    <h2>Acknowledgements</h2>
    <p>
      The authors are grateful for the supervision of Prof. Dr. Stefan Decker and Prof. Dr.-Ing. Klaus Wehrle.
    </p>
    <!-- Slightly customized Widoco acknowledgements -->
    <p>
      The authors would like to thank <a href="http://www.essepuntato.it/">Silvio Peroni</a> for developing <a href="http://www.essepuntato.it/lode">LODE</a>, a Live OWL Documentation Environment, which is used for representing the Cross Referencing Section of this document and <a href="https://w3id.org/people/dgarijo">Daniel Garijo</a> for developing <a href="https://github.com/dgarijo/Widoco">Widoco</a>, the program used to create the template used in this documentation.
    </p>
    <p>
      The authors would further like to thank the reviewers of the ESWC paper [[?ReShare]] for providing insightful and constructive feedback on the topic.
    </p>
    <p>
      Funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany's Excellence Strategy -- EXC-2023 Internet of Production -- 390621612.
    </p>
  </section>

  <section id="tof" class="appendix"></section>
</body>

</html>